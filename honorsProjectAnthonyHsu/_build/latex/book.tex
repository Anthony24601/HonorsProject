%% Generated by Sphinx.
\def\sphinxdocclass{jupyterBook}
\documentclass[letterpaper,10pt,english]{jupyterBook}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}
%% memoir class requires extra handling
\makeatletter\@ifclassloaded{memoir}
{\ifdefined\memhyperindexfalse\memhyperindexfalse\fi}{}\makeatother

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\defaultfontfeatures[\rmfamily,\sffamily,\ttfamily]{}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}



\setmainfont{FreeSerif}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Italic,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldItalic
]
\setsansfont{FreeSans}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]
\setmonofont{FreeMono}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]



\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}



        % Start of preamble defined in sphinx-jupyterbook-latex %
         \usepackage[Latin,Greek]{ucharclasses}
        \usepackage{unicode-math}
        % fixing title of the toc
        \addto\captionsenglish{\renewcommand{\contentsname}{Contents}}
        \hypersetup{
            pdfencoding=auto,
            psdextra
        }
        % End of preamble defined in sphinx-jupyterbook-latex %
        

\title{My sample book}
\date{Apr 14, 2024}
\release{}
\author{The Jupyter Book Community}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{intro::doc}}


\sphinxAtStartPar
This is a small sample book to give you a feel for how book content is
structured.
It shows off a few of the major file types, as well as some sample content.
It does not go in\sphinxhyphen{}depth into any particular topic \sphinxhyphen{} check out \sphinxhref{https://jupyterbook.org}{the Jupyter Book documentation} for more information.

\sphinxAtStartPar
Check out the content pages bundled with this sample book to see more.
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{data::doc}]{\sphinxcrossref{Intro and Setup}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{interpolation::doc}]{\sphinxcrossref{Interpolation and Regularizers}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{loss::doc}]{\sphinxcrossref{Loss}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{finite_gradient::doc}]{\sphinxcrossref{Gradient Calculations: Finite Differences}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{dirty_gradient::doc}]{\sphinxcrossref{Gradient Calculations: “Dirtying” the Image}}}

\end{itemize}

\sphinxstepscope


\chapter{Intro and Setup}
\label{\detokenize{data:intro-and-setup}}\label{\detokenize{data::doc}}
\sphinxAtStartPar
These are all the libraries that are needed

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{cmath}
\PYG{k+kn}{import} \PYG{n+nn}{math}
\PYG{k+kn}{from} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{optimize} \PYG{k+kn}{import} \PYG{n}{fmin}\PYG{p}{,} \PYG{n}{minimize}
\PYG{k+kn}{from} \PYG{n+nn}{astropy} \PYG{k+kn}{import} \PYG{n}{units} \PYG{k}{as} \PYG{n}{u}
\PYG{k+kn}{from} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{interpolate} \PYG{k+kn}{import} \PYG{n}{RegularGridInterpolator}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{import} \PYG{n+nn}{copy}
\PYG{o}{\PYGZpc{}}\PYG{k}{matplotlib} inline
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
As the earth spins, we trace out a track in the Fourier domain in order to give us one snapshot of the black hole image. On earth we create a sinusoidal wave in order to amplify the data that we recieve from our snapshot. This create two different sine bands. One being hi and the other being low. We can use these two data sets to create two different images for the same day in practice. Theoretically they should create the same image


\chapter{Paste images here}
\label{\detokenize{data:paste-images-here}}

\section{Data Details}
\label{\detokenize{data:data-details}}
\sphinxAtStartPar
The data set from EHT (The Event Horizon Telescope) and from the HOPS pipeline (software from MIT), comes in multiple sets. From one data collection, we are given a hi band and low band sets.

\sphinxAtStartPar
Suppose that the sky signal is some radio wave \(Sky = \epsilon \sin(\omega t)\). The signal however is extremely small which make it hard to detect. In order to pick out this signal, we use a local oscillator which generates another wave (i.e. \(LO = A \sin(\omega't)\)) where A is some amplitude. Once these two signals are multiplied together, we get something like so: \(Sky \times LO = A \epsilon \sin(\omega t) \times \sin(\omega' t) = A \epsilon {\sin[(\omega + \omega')t] + sin [(\omega - \omega')t]}\).

\sphinxAtStartPar
Here we have \(A \epsilon\) be an amplitude such that the signals are big enough for our instruments to detect.
The \(\omega + \omega'\) and \(\omega - \omega'\) results in two bands which the data is taken from


\chapter{Some Details about the Table}
\label{\detokenize{data:some-details-about-the-table}}
\sphinxAtStartPar
time is the time that it was taken. This time stamp is not used because we assume things are static.

\sphinxAtStartPar
T1 and T2 are the two telescopes.

\sphinxAtStartPar
U and V are the fourier location of the fourier domain. When we plot each point in the fourier domain, we should obtain something like below \#HEREEE They are given in terms of lambda.

\sphinxAtStartPar
Iamp is the Amplitude of the Fourier Coefficient

\sphinxAtStartPar
IPhase is the Phase of the Fourier Coefficient in degrees

\sphinxAtStartPar
ISigma is the error or the noisiness of the data point

\sphinxAtStartPar
Here, we will start to preprocess the data. First we will create a class to hold the information is a more accessible manner

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{data}\PYG{p}{:}
    \PYG{n}{u}\PYG{p}{:} \PYG{n+nb}{float}
    \PYG{n}{v}\PYG{p}{:} \PYG{n+nb}{float}
    \PYG{n}{phase}\PYG{p}{:} \PYG{n+nb}{float}
    \PYG{n}{amp}\PYG{p}{:} \PYG{n+nb}{float}
    \PYG{n}{sigma}\PYG{p}{:} \PYG{n+nb}{float}
    \PYG{n}{vis\PYGZus{}data}\PYG{p}{:} \PYG{n+nb}{complex}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{phase}\PYG{p}{,} \PYG{n}{amp}\PYG{p}{,} \PYG{n}{sigma}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{u} \PYG{o}{=} \PYG{n}{u}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{v} \PYG{o}{=} \PYG{n}{v}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{phase} \PYG{o}{=} \PYG{n}{phase}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{amp} \PYG{o}{=} \PYG{n}{amp}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{sigma} \PYG{o}{=} \PYG{n}{sigma}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{vis\PYGZus{}data} \PYG{o}{=} \PYG{n}{amp} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{n}{j} \PYG{o}{*} \PYG{n}{math}\PYG{o}{.}\PYG{n}{radians}\PYG{p}{(}\PYG{n}{phase}\PYG{p}{)}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}repr\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{[u: }\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{u}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{, v: }\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{v}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{]}\PYG{l+s+s2}{\PYGZdq{}}

    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}str\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{[u: }\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{u}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{, v: }\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{v}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{]}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
The next few cells read the data from a csv file

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{process\PYGZus{}data}\PYG{p}{(}\PYG{n}{data\PYGZus{}df}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{coords} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{data\PYGZus{}list} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{data\PYGZus{}df}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{data\PYGZus{}list}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{data}\PYG{p}{(}\PYG{n}{data\PYGZus{}df}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{U(lambda)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{data\PYGZus{}df}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{V(lambda)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{data\PYGZus{}df}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Iphase(d)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{data\PYGZus{}df}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Iamp(Jy)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{data\PYGZus{}df}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Isigma(Jy)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{coords}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{[}\PYG{n}{data\PYGZus{}df}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{U(lambda)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{data\PYGZus{}df}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{V(lambda)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{coords} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{coords}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{read\PYGZus{}data}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{:} \PYG{n+nb}{str}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{read\PYGZus{}csv}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{df}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df} \PYG{o}{=} \PYG{n}{read\PYGZus{}data}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./data/SR1\PYGZus{}M87\PYGZus{}2017\PYGZus{}095\PYGZus{}hi\PYGZus{}hops\PYGZus{}netcal\PYGZus{}StokesI.csv}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{coords}\PYG{p}{,} \PYG{n}{data\PYGZus{}list} \PYG{o}{=} \PYG{n}{process\PYGZus{}data}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{n}{df}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
      \PYGZsh{}time(UTC)  T1  T2     U(lambda)     V(lambda)  Iamp(Jy)  Iphase(d)  \PYGZbs{}
0       0.768056  AA  LM  1.081710e+09 \PYGZhy{}3.833722e+09  0.014292  \PYGZhy{}118.9454   
1       0.768056  AA  PV \PYGZhy{}4.399933e+09 \PYGZhy{}4.509480e+09  0.136734     5.8638   
2       0.768056  AA  AP  8.349088e+05 \PYGZhy{}1.722271e+06  1.119780    58.1095   
3       0.768056  AP  LM  1.080840e+09 \PYGZhy{}3.832004e+09  0.018448  \PYGZhy{}137.6802   
4       0.768056  AP  PV \PYGZhy{}4.400757e+09 \PYGZhy{}4.507747e+09  0.139619   \PYGZhy{}57.1724   
...          ...  ..  ..           ...           ...       ...        ...   
6453    8.165278  AZ  LM \PYGZhy{}1.078324e+09  1.029597e+09  0.315983    10.9377   
6454    8.165278  AZ  JC  3.392180e+09  9.968579e+08  0.058864    46.0474   
6455    8.165278  JC  LM \PYGZhy{}4.470504e+09  3.273711e+07  0.108582  \PYGZhy{}178.7050   
6456    8.165278  JC  SM  1.745735e+04 \PYGZhy{}1.192282e+05  1.123722   \PYGZhy{}29.5589   
6457    8.165278  LM  SM  4.470522e+09 \PYGZhy{}3.285633e+07  0.104931    96.6936   

      Isigma(Jy)  
0       0.005847  
1       0.004968  
2       0.005243  
3       0.044576  
4       0.032591  
...          ...  
6453    0.030449  
6454    0.090288  
6455    0.043965  
6456    0.091870  
6457    0.028783  

[6458 rows x 8 columns]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}}\PYG{k}{run} ./utility.ipynb
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\chapter{Interpolation and Regularizers}
\label{\detokenize{interpolation:interpolation-and-regularizers}}\label{\detokenize{interpolation::doc}}
\sphinxAtStartPar
In this notebook, we will talk about interpolating coordinate values from an image as well as calculating the regularizer
for gradient descent.


\section{Background on FOV and k\sphinxhyphen{}space}
\label{\detokenize{interpolation:background-on-fov-and-k-space}}
\sphinxAtStartPar
FOV stands for Field of view and it refers to the distance over which an image is acquired or displayed. These images are usually captured by some sort of signal processing like telescopes and MRIs. The FOV and pixel width determine the number of units in the fourier domain that must be obtained in order to reconstruct an image.

\sphinxAtStartPar
For the sakes of this research and example, FOVx = FOVy = FOV and \(\Delta x = \Delta y = \Delta w\). Where w is the pixel width.

\sphinxAtStartPar
The Fourier projection of spatial frequencies all follow a similar pattern. Instead of regular sine waves, we see complex exponentials
, cos n \(\omega\) t + i sin n \(\omega\) t. Each pair of samples lines differ by exactly 1 cycle over the FOV. This means that \(\Delta k = k_{n+1} - k_n = \frac{n+1}{FOV}-\frac{n}{FOV} = \frac{1}{FOV}\)


\section{Interpolation}
\label{\detokenize{interpolation:interpolation}}
\sphinxAtStartPar
In this notebook, we have an image that is being linearly transformed using fourier transforms. We do this in order to allow us to use direct comparisons between our image (in real space but being transformed into fourier space) and the data obtained by the telescopes (which are in the spectral or fourier domain.)

\sphinxAtStartPar
When doing this transformation, we obtain a grid of points extracted from the image which do not necessarily line up with the U and V coordinates from the dataset. Instead, we must interpolate or estimate the values of the data points using existing known points in our grid.

\sphinxAtStartPar
Furthermore, in order to translate correctly from image space to fourier space, we need to multiply the grids (kx and ky) by k\_FOV. The calculation for this is explained above.

\sphinxAtStartPar
It is important to note that the more grid points we have, the bigger the image. Thus the size of our Fourier Domain is the Number of pixels of the image by k\_FOV. If our FOV is very small, then the width of the fourier grid becomes large.

\sphinxAtStartPar
Next we want to interpolate the complex value at each coordinate. RegularGridInterpolator however cannot interpolate complex numbers so we interpolate the real and imaginary parts separately and then combined them for the final result.

\sphinxAtStartPar
Finally, we use a linear method for interpolation due to it’s local interpolation scheme. The other schemes that RegularGridInterpolator offers uses a C\textasciicircum{}2\sphinxhyphen{}smooth split which is a non\sphinxhyphen{}local scheme. Since we wanted to optimize the computation time, we chose the linear method.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Assumption image is 80x80 pixels}
\PYG{c+c1}{\PYGZsh{} Pass in array of u,v coords then return array of interpolated values}
\PYG{k}{def} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{FOV}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    image is a 80x80 pixel image that represents our reconstructed image}
\PYG{l+s+sd}{    coords is a list of u,v coordinates that we obtained from our data}
\PYG{l+s+sd}{    FOV is the Field of view from the telescopes. For the EHT data, our FOV is 100 micro ascs.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}

    \PYG{n}{ft\PYGZus{}image} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fftshift}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fft2}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{p}{)}

    \PYG{n}{k\PYGZus{}FOV} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{FOV}

    \PYG{n}{kx} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fftshift}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fftfreq}\PYG{p}{(}\PYG{n}{ft\PYGZus{}image}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{d} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{p}{(}\PYG{n}{k\PYGZus{}FOV}\PYG{o}{*}\PYG{n}{ft\PYGZus{}image}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{ky} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fftshift}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fftfreq}\PYG{p}{(}\PYG{n}{ft\PYGZus{}image}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{d} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{p}{(}\PYG{n}{k\PYGZus{}FOV}\PYG{o}{*}\PYG{n}{ft\PYGZus{}image}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}

    \PYG{n}{interp\PYGZus{}real} \PYG{o}{=} \PYG{n}{RegularGridInterpolator}\PYG{p}{(}\PYG{p}{(}\PYG{n}{kx}\PYG{p}{,} \PYG{n}{ky}\PYG{p}{)}\PYG{p}{,} \PYG{n}{ft\PYGZus{}image}\PYG{o}{.}\PYG{n}{real}\PYG{p}{,} \PYG{n}{bounds\PYGZus{}error}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{method}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{linear}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{interp\PYGZus{}imag} \PYG{o}{=} \PYG{n}{RegularGridInterpolator}\PYG{p}{(}\PYG{p}{(}\PYG{n}{kx}\PYG{p}{,} \PYG{n}{ky}\PYG{p}{)}\PYG{p}{,} \PYG{n}{ft\PYGZus{}image}\PYG{o}{.}\PYG{n}{imag}\PYG{p}{,} \PYG{n}{bounds\PYGZus{}error}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{method}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{linear}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{n}{real} \PYG{o}{=} \PYG{n}{interp\PYGZus{}real}\PYG{p}{(}\PYG{n}{coords}\PYG{p}{)}
    \PYG{n}{imag} \PYG{o}{=} \PYG{n}{interp\PYGZus{}imag}\PYG{p}{(}\PYG{n}{coords}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{real} \PYG{o}{+} \PYG{n}{imag} \PYG{o}{*} \PYG{l+m+mi}{1}\PYG{n}{j}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Here we do some tests using interp\_real and interp\_imag to verify that they do interpolate a value using a linear scheme. First we start with a very basic 5x5 grid.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}
\PYG{n}{y} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}
\PYG{n}{z} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{]}
\PYG{n}{interp} \PYG{o}{=} \PYG{n}{RegularGridInterpolator}\PYG{p}{(}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}\PYG{p}{,}\PYG{n}{z}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Expected: 1, Actual:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{interp}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Expected: 2.5, Actual:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{interp}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{1.5}\PYG{p}{,}\PYG{l+m+mf}{2.5}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Expected: 1, Actual: [1.]
Expected: 2.5, Actual: [2.5]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Now, here is a test on a fourier transformed image

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sample} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{loadtxt}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{images/interpolate\PYGZus{}test.csv}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{delimiter}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(\PYGZhy{}0.5, 179.5, 179.5, \PYGZhy{}0.5)
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{dce7dafd214477f1739ab7335fe133516148f92841137ae0ca457ded5c0e1c46}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ft\PYGZus{}image} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fftshift}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fft2}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{interpolated\PYGZus{}points} \PYG{o}{=} \PYG{n}{interpolate}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{,}\PYG{p}{[}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{9.0e+09}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{9.0e+09}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{8.9e+09}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{9.0e+09}\PYG{p}{]} \PYG{p}{,}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{8.95e+09}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{9.0e+09}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}\PYG{l+m+mi}{180}\PYG{o}{*}\PYG{n}{u}\PYG{o}{.}\PYG{n}{uas}\PYG{o}{.}\PYG{n}{to}\PYG{p}{(}\PYG{n}{u}\PYG{o}{.}\PYG{n}{rad}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Expected:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ft\PYGZus{}image}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{Actual:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{interpolated\PYGZus{}points}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{Expected:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ft\PYGZus{}image}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{Actual:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{interpolated\PYGZus{}points}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{Expected: }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{p}{(}\PYG{n}{ft\PYGZus{}image}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{+}\PYG{n}{ft\PYGZus{}image}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{Actual:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{interpolated\PYGZus{}points}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Expected: (3.0000000019953994\PYGZhy{}2.1431905139479568e\PYGZhy{}09j) 
Actual: (\PYGZhy{}335133.52213257825+690198.3841637481j)

Expected: (38.20989061676637+0.6177808031820264j) 
Actual: (\PYGZhy{}231640.3460875617+376131.9723567965j)

Expected:  (20.604945309380888+0.30889040051941796j) 
Actual: (\PYGZhy{}283386.93411007+533165.1782602723j)
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Below is an interpolation subroutine written by Misha Stepanov.

\sphinxAtStartPar
The code provides an insight into a local interpolation scheme using 2D cubic splines. It is local in a sense that only 12 grid points around the point at which we are interpolating is used to contribute the the estimation. The code the interpolation is done with data being wrapped into a 2D torus and the xy\sphinxhyphen{}coordinates are supplied assuming that the step of the grid in both the x and y directions are equal to 1


\subsection{include stuff about cublic splines? Get permission first}
\label{\detokenize{interpolation:include-stuff-about-cublic-splines-get-permission-first}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{cubf1}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{:}
  \PYG{n}{cf1} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{+} \PYG{n}{x} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{o}{*}\PYG{n}{x}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{+} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{n}{y}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{)}
  \PYG{n}{cf2} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{+} \PYG{n}{y} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{o}{*}\PYG{n}{y}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{+} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{n}{x}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{)}
  \PYG{k}{return} \PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{p}{(}\PYG{n}{cf1} \PYG{o}{+} \PYG{n}{cf2}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{cubf2}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{:}
  \PYG{k}{return} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n}{x}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{+} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{n}{y}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{cubic12}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{X}\PYG{p}{)}\PYG{p}{:}
  \PYG{n}{N} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{;}  \PYG{n}{F} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}\PYG{p}{)}
  \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{m} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{mod}\PYG{p}{(}\PYG{n}{X}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{N}\PYG{p}{)}\PYG{p}{;}  \PYG{n}{x}\PYG{p}{,} \PYG{n}{y} \PYG{o}{=} \PYG{n}{m} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{floor}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}
    \PYG{n}{m1}\PYG{p}{,} \PYG{n}{m2} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{floor}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{mod}\PYG{p}{(}\PYG{n}{m} \PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{2.}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{N}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{)}
    \PYG{n}{F}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}  \PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{m1} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{m2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{*}\PYG{n}{cubf1}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}
    \PYG{n}{F}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{m1} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{m2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{*}\PYG{n}{cubf1}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}
    \PYG{n}{F}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{m1} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{m2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*}\PYG{n}{cubf1}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{)}
    \PYG{n}{F}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{m1} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{m2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*}\PYG{n}{cubf1}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{,} \PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{)}
    \PYG{n}{F}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{m1} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{m2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{*}\PYG{n}{cubf2}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}
    \PYG{n}{F}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{m1} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{m2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{o}{*}\PYG{n}{cubf2}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}
    \PYG{n}{F}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{m1}    \PYG{p}{,} \PYG{n}{m2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{*}\PYG{n}{cubf2}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}
    \PYG{n}{F}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{m1} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{m2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{o}{*}\PYG{n}{cubf2}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,} \PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{)}
    \PYG{n}{F}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{m1} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{m2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*}\PYG{n}{cubf2}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{)}
    \PYG{n}{F}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{m1} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{m2}    \PYG{p}{]}\PYG{o}{*}\PYG{n}{cubf2}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}
    \PYG{n}{F}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{m1}    \PYG{p}{,} \PYG{n}{m2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*}\PYG{n}{cubf2}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{,} \PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{)}
    \PYG{n}{F}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{m1} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{m2}    \PYG{p}{]}\PYG{o}{*}\PYG{n}{cubf2}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{,} \PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{)}
  \PYG{k}{return} \PYG{n}{F}

\PYG{k}{def} \PYG{n+nf}{func}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{:}
  \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{*}\PYG{n}{x}\PYG{p}{)} \PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{*}\PYG{p}{(}\PYG{n}{x} \PYG{o}{+} \PYG{n}{y}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
  \PYG{n}{x} \PYG{o}{=} \PYG{n}{i} \PYG{o}{/} \PYG{l+m+mf}{10.}
  \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{j} \PYG{o}{/} \PYG{l+m+mf}{10.}
    \PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{func}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}

\PYG{n}{X} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{10000}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10000}\PYG{p}{)}\PYG{p}{:}
  \PYG{n}{X}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{i} \PYG{o}{/} \PYG{l+m+mf}{1000.}
  \PYG{n}{X}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{i} \PYG{o}{/} \PYG{l+m+mf}{2000.}
\PYG{n}{F} \PYG{o}{=} \PYG{n}{cubic12}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{X}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10000}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10000}\PYG{p}{)}\PYG{p}{:}
  \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{X}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{X}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{F}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{func}\PYG{p}{(}\PYG{n}{X}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{/} \PYG{l+m+mf}{10.}\PYG{p}{,} \PYG{n}{X}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{/} \PYG{l+m+mf}{10.}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
9.99 4.995 \PYGZhy{}1.0058598083263428 \PYGZhy{}1.0062387310745087
9.991 4.9955 \PYGZhy{}1.0052755185370548 \PYGZhy{}1.0056188621460636
9.992 4.996 \PYGZhy{}1.004690839850659 \PYGZhy{}1.0049981027528014
9.993 4.9965 \PYGZhy{}1.0041057771382442 \PYGZhy{}1.0043764531360648
9.994 4.997 \PYGZhy{}1.0035203352965503 \PYGZhy{}1.0037539135379836
9.995 4.9975 \PYGZhy{}1.0029345192480468 \PYGZhy{}1.0031304842014765
9.996 4.998 \PYGZhy{}1.002348333941004 \PYGZhy{}1.002506165370251
9.997 4.9985 \PYGZhy{}1.001761784349569 \PYGZhy{}1.0018809572888083
9.998 4.999 \PYGZhy{}1.001174875473833 \PYGZhy{}1.0012548602024367
9.999 4.9995 \PYGZhy{}1.0005876123399073 \PYGZhy{}1.0006278743572115
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Regularization}
\label{\detokenize{interpolation:regularization}}
\sphinxAtStartPar
Here we start to calculate regularizers. We do so in order to smooth image and add some bias into the model to prevent it from overfitting the training data. Regularizers allow machine learning models to generalize to new examples that it has not seen during training.

\sphinxAtStartPar
The regularizer below implements a regularization method called “total squared variation.” This method favors smooth edges and is often used for astronomical image reconstruction.

\sphinxAtStartPar
The formula for a TSV regularizer is

\sphinxAtStartPar
\(-\sum_l \sum_m[(I_{l+1,m}-I_{l,m})^2+(I_{l,m+1}-I_{l,m})^2]\)

\sphinxAtStartPar
where l and m are pixel coordinates and I is the image. There are however other similar regularizers like Total variation that favors pixel\sphinxhyphen{}to\sphinxhyphen{}pixel smoothness.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} p is the exponent of the regularizing terms}
\PYG{c+c1}{\PYGZsh{} The smaller p the more sensitive it is to noise}
\PYG{c+c1}{\PYGZsh{} TSV = Total Squared Variation}
\PYG{k}{def} \PYG{n+nf}{calc\PYGZus{}regularizer}\PYG{p}{(}\PYG{n}{image}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{,} \PYG{n}{tsv}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{p}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{tsv} \PYG{o+ow}{and} \PYG{n}{p} \PYG{o}{==} \PYG{k+kc}{None}\PYG{p}{:}
        \PYG{k}{raise} \PYG{n+ne}{Exception}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{p value not set}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{reg} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{k}{if} \PYG{n}{tsv}\PYG{p}{:}
        \PYG{n}{image\PYGZus{}lshift} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{subok}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
        \PYG{n}{image\PYGZus{}lshift} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{roll}\PYG{p}{(}\PYG{n}{image\PYGZus{}lshift}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
        \PYG{n}{image\PYGZus{}lshift}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{image\PYGZus{}lshift}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]} 
        \PYG{n}{image\PYGZus{}upshift} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{subok}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
        \PYG{n}{image\PYGZus{}upshift} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{roll}\PYG{p}{(}\PYG{n}{image\PYGZus{}upshift}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{n}{image\PYGZus{}upshift}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{image\PYGZus{}upshift}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]} 

        \PYG{n}{term\PYGZus{}1} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{power}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{absolute}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{subtract}\PYG{p}{(}\PYG{n}{image\PYGZus{}lshift}\PYG{p}{,} \PYG{n}{image}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}\PYG{n}{p}\PYG{p}{)}
        \PYG{n}{term\PYGZus{}2} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{power}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{absolute}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{subtract}\PYG{p}{(}\PYG{n}{image\PYGZus{}upshift}\PYG{p}{,} \PYG{n}{image}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}\PYG{n}{p}\PYG{p}{)}
        \PYG{n}{reg} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{term\PYGZus{}1}\PYG{p}{,}\PYG{n}{term\PYGZus{}2}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{return} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{n}{reg}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Here we test the calc\_regulaizer function using an empty image, a monotone image, and a noisy image.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{empty\PYGZus{}image} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{80}\PYG{p}{,}\PYG{l+m+mi}{80}\PYG{p}{)}\PYG{p}{)} 
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{empty\PYGZus{}image}\PYG{p}{,} \PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(\PYGZhy{}0.5, 79.5, 79.5, \PYGZhy{}0.5)
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{50044725cf3b7bb9aba8413280e2b5fac297b8a84f56bbf478d426329bef7e14}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{noisy\PYGZus{}image} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{l+m+mi}{80}\PYG{p}{,}\PYG{l+m+mi}{80}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{noisy\PYGZus{}image}\PYG{p}{,} \PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(\PYGZhy{}0.5, 79.5, 79.5, \PYGZhy{}0.5)
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{73262e3d274e3f09353042637381612c5f91412919cb9f05389a04b61384ca3a}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{monotone\PYGZus{}image} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{full}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{80}\PYG{p}{,}\PYG{l+m+mi}{80}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{monotone\PYGZus{}image}\PYG{p}{,} \PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(\PYGZhy{}0.5, 79.5, 79.5, \PYGZhy{}0.5)
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{6be4452fe7135bd154aa8e9b3b8b2f5a0a719dc140f6f685c13ea78a004b870f}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Empty:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{calc\PYGZus{}regularizer}\PYG{p}{(}\PYG{n}{empty\PYGZus{}image}\PYG{p}{,}\PYG{k+kc}{True}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Noisy:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{calc\PYGZus{}regularizer}\PYG{p}{(}\PYG{n}{noisy\PYGZus{}image}\PYG{p}{,}\PYG{k+kc}{True}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Monotone:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{calc\PYGZus{}regularizer}\PYG{p}{(}\PYG{n}{monotone\PYGZus{}image}\PYG{p}{,}\PYG{k+kc}{True}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Empty: \PYGZhy{}0.0
Noisy: \PYGZhy{}2108.9772836537513
Monotone: 0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Here we see that the regularizer favors smooth images over noisy/rough ones. It is important to note that both the empty image and the monotone image have a regularizer of 0. This is because we weight the images towards smoother images.

\sphinxAtStartPar
This is the gradient of the regularizer.
We calculate each point in the picture by doing \(x_{i+1,j} + x_{i-1,j} + x_{i,j+1} + x_{i,j-1} - 4x_{i,j}\) for each i,j pixels

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{gradient\PYGZus{}regularizer}\PYG{p}{(}\PYG{n}{image}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{image\PYGZus{}lshift} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{subok}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
    \PYG{n}{image\PYGZus{}lshift} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{roll}\PYG{p}{(}\PYG{n}{image\PYGZus{}lshift}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{n}{image\PYGZus{}lshift}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{image\PYGZus{}lshift}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]} 
    \PYG{n}{image\PYGZus{}upshift} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{subok}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
    \PYG{n}{image\PYGZus{}upshift} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{roll}\PYG{p}{(}\PYG{n}{image\PYGZus{}upshift}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n}{image\PYGZus{}upshift}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{image\PYGZus{}upshift}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]} 
    \PYG{n}{image\PYGZus{}rshift} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{subok}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
    \PYG{n}{image\PYGZus{}rshift} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{roll}\PYG{p}{(}\PYG{n}{image\PYGZus{}rshift}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{n}{image\PYGZus{}rshift}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{image\PYGZus{}rshift}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]} 
    \PYG{n}{image\PYGZus{}dshift} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{subok}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
    \PYG{n}{image\PYGZus{}dshift} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{roll}\PYG{p}{(}\PYG{n}{image\PYGZus{}dshift}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n}{image\PYGZus{}dshift}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{image\PYGZus{}lshift}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} 
    \PYG{n}{g\PYGZus{}reg} \PYG{o}{=} \PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{image} \PYG{o}{\PYGZhy{}} \PYG{n}{image\PYGZus{}lshift} \PYG{o}{\PYGZhy{}} \PYG{n}{image\PYGZus{}upshift} \PYG{o}{\PYGZhy{}} \PYG{n}{image\PYGZus{}rshift} \PYG{o}{\PYGZhy{}} \PYG{n}{image\PYGZus{}dshift}
    \PYG{k}{return} \PYG{n}{g\PYGZus{}reg}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Empty:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{gradient\PYGZus{}regularizer}\PYG{p}{(}\PYG{n}{empty\PYGZus{}image}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Noisy:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{gradient\PYGZus{}regularizer}\PYG{p}{(}\PYG{n}{noisy\PYGZus{}image}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Monotone:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{gradient\PYGZus{}regularizer}\PYG{p}{(}\PYG{n}{monotone\PYGZus{}image}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Empty:
 [[0. 0. 0. ... 0. 0. 0.]
 [0. 0. 0. ... 0. 0. 0.]
 [0. 0. 0. ... 0. 0. 0.]
 ...
 [0. 0. 0. ... 0. 0. 0.]
 [0. 0. 0. ... 0. 0. 0.]
 [0. 0. 0. ... 0. 0. 0.]]
Noisy:
 [[ 1.04025833  0.31293167 \PYGZhy{}1.48128372 ...  0.22462667  0.2264166
   0.58445354]
 [\PYGZhy{}1.45402225  1.290966   \PYGZhy{}1.51713099 ...  1.15713575 \PYGZhy{}0.19833866
  \PYGZhy{}0.09194965]
 [ 0.1087026   1.74525518 \PYGZhy{}1.26408352 ... \PYGZhy{}0.34713719 \PYGZhy{}0.77749415
  \PYGZhy{}0.57635953]
 ...
 [ 1.18315853  0.50915739 \PYGZhy{}0.48980817 ... \PYGZhy{}1.33555771  2.27147516
   0.3352341 ]
 [\PYGZhy{}1.47661333  0.64698704 \PYGZhy{}1.56710514 ...  0.77084388 \PYGZhy{}2.04752708
  \PYGZhy{}0.40909334]
 [ 1.24388255 \PYGZhy{}1.59917979  1.76252233 ... \PYGZhy{}0.75868688  0.32312203
   0.84747094]]
Monotone:
 [[0 0 0 ... 0 0 0]
 [0 0 0 ... 0 0 0]
 [0 0 0 ... 0 0 0]
 ...
 [0 0 0 ... 0 0 0]
 [0 0 0 ... 0 0 0]
 [0 0 0 ... 0 0 0]]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}}\PYG{k}{run} ./utility.ipynb
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\chapter{Loss}
\label{\detokenize{loss:loss}}\label{\detokenize{loss::doc}}
\sphinxAtStartPar
The Loss function is trying to compare the data with the image and see if they agree with each other.

\sphinxAtStartPar
Let \(I(x,y)\) be the image and we transform it into \(\hat{I} (x,y)\) by using fourier transfroms described in the the interpolate section of the previous notebook.

\sphinxAtStartPar
Next we compare each interpolated point with its data term counterpart and get the equation for loss to be:
\begin{equation*}
\begin{split}J = \sum(\frac{|\hat{I} - D|^2}{\sigma^2})\end{split}
\end{equation*}
\sphinxAtStartPar
\(\sigma\) here is the error for each data point.

\sphinxAtStartPar
Finally, we add the regularizer to the loss using the method in the previous notebook.


\section{Data Term calculation}
\label{\detokenize{loss:data-term-calculation}}
\sphinxAtStartPar
We have above that \(\hat{I}\) is in the Fourier Domain. In order to compute the data term, we calculate the term as \(D = \text{Amp} * e^{i*\text{phase}}\).

\sphinxAtStartPar
It is important to note that the phase in Z is in radians, not degrees

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{loss}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{:} \PYG{n+nb}{list}\PYG{p}{[}\PYG{n}{data}\PYG{p}{]}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{p} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{reg\PYGZus{}weight} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{FOV} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{o}{*}\PYG{n}{u}\PYG{o}{.}\PYG{n}{uas}\PYG{o}{.}\PYG{n}{to}\PYG{p}{(}\PYG{n}{u}\PYG{o}{.}\PYG{n}{rad}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{error\PYGZus{}sum} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{n}{vis\PYGZus{}images} \PYG{o}{=} \PYG{n}{interpolate}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{FOV}\PYG{p}{)}
    
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{vis\PYGZus{}data} \PYG{o}{=} \PYG{n}{data\PYGZus{}list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{amp} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{n}{j} \PYG{o}{*} \PYG{n}{math}\PYG{o}{.}\PYG{n}{radians}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{phase}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{vis\PYGZus{}image} \PYG{o}{=} \PYG{n}{vis\PYGZus{}images}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
        \PYG{n}{error} \PYG{o}{=} \PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{vis\PYGZus{}image}\PYG{o}{\PYGZhy{}}\PYG{n}{vis\PYGZus{}data}\PYG{p}{)} \PYG{o}{/} \PYG{n}{data\PYGZus{}list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{sigma}\PYG{p}{)} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}
        \PYG{n}{error\PYGZus{}sum} \PYG{o}{+}\PYG{o}{=} \PYG{n}{error}
    
    \PYG{k}{return} \PYG{n}{error\PYGZus{}sum} \PYG{o}{+} \PYG{n}{reg\PYGZus{}weight} \PYG{o}{*} \PYG{n}{calc\PYGZus{}regularizer}\PYG{p}{(}\PYG{n}{image}\PYG{o}{=}\PYG{n}{image}\PYG{p}{,} \PYG{n}{tsv}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{p}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Furthermore into the data}
\label{\detokenize{loss:furthermore-into-the-data}}
\sphinxAtStartPar
What we are doing here is a simplified version of the loss function. In reality, the loss is more complicated due to other factors.

\sphinxAtStartPar
Because of the method of combining signal data from many telescopes, we get errors that may throw off the data terms.

\sphinxAtStartPar
How would we change our loss function?


\subsection{Method One: Gain}
\label{\detokenize{loss:method-one-gain}}
\sphinxAtStartPar
We add a new function called the Gain which represents the telescoping errors. It is a smooth function in time that has a phase and amplitude. We multiply it with the data term to result in:
\begin{equation*}
\begin{split}J = \sum(\frac{|\hat{I} - G D|^2}{\sigma^2})\end{split}
\end{equation*}
\sphinxAtStartPar
Now when we try to minimize the image, we are also trying to minimize G.


\subsection{Method Two: Cosher Phase}
\label{\detokenize{loss:method-two-cosher-phase}}
\sphinxAtStartPar
The other way is to take into the account the Cosher Phase.

\sphinxAtStartPar
Using three telescopes we get:
\begin{equation*}
\begin{split} \sum (\frac{|\phi_{1,2} + \phi_{2,3} + \phi_{3,1} - \phi_{\hat{I}}|^2}{\sigma^2})\end{split}
\end{equation*}
\sphinxAtStartPar
\(\phi_{1,2} + \phi_{2,3} + \phi_{3,1}\) is called the Cosher Phase \(CP\) which is independent of the telescope error and is taken from the data. \(\phi_{\hat{I}}\) is a Cosher Phase computed from the image.

\sphinxAtStartPar
In practice, these are the two major methods in order to fit the image to the data.


\section{Testing the function}
\label{\detokenize{loss:testing-the-function}}
\sphinxAtStartPar
Below we have a image that was generated for testing purposes. Sometimes we want to shift the image in someway so that the loss function can be optimized further. In EHT, they have tested with many variations and come up with the loss being the best with the ring centered in the middle. We will test this claim below.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sample} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{loadtxt}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{images/data.csv}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{delimiter}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(\PYGZhy{}0.5, 79.5, 79.5, \PYGZhy{}0.5)
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{09be506f97fad65651b949fb269182d142b16cb4c9f2ecebe9fd3a98f4952fd3}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Here we generate a coords and data\_list list by sampling data from the ring (not the noise around the ring).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{do\PYGZus{}sample}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{coords} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{data\PYGZus{}list} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{ft\PYGZus{}image} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fftshift}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fft2}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{coords}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{10}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{10}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{data\PYGZus{}list}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{(}\PYG{n}{coords}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{ft\PYGZus{}image}\PYG{p}{[}\PYG{n}{coords}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{+}\PYG{l+m+mi}{40}\PYG{p}{]}\PYG{p}{[}\PYG{n}{coords}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{l+m+mi}{40}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{coords}\PYG{p}{,} \PYG{n}{data\PYGZus{}list} \PYG{o}{=} \PYG{n}{do\PYGZus{}sample}\PYG{p}{(}\PYG{l+m+mi}{25}\PYG{p}{)}
\PYG{n}{data\PYGZus{}list}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[((3, 0), (9.345246066663234\PYGZhy{}12.763088241472762j)),
 ((1, \PYGZhy{}4), (19.26638997942068+0.645458355184074j)),
 ((4, 1), (16.740754111448133+2.309720618467048j)),
 ((0, 0), (\PYGZhy{}130.7977532545254+0j)),
 ((3, 0), (9.345246066663234\PYGZhy{}12.763088241472762j)),
 ((4, 2), (\PYGZhy{}16.213537172215425+2.677957292860941j)),
 ((\PYGZhy{}4, \PYGZhy{}1), (16.740754111448133\PYGZhy{}2.3097206184670487j)),
 ((2, \PYGZhy{}2), (\PYGZhy{}20.259515490227393+0.5869595357657675j)),
 ((\PYGZhy{}3, 0), (9.345246066663236+12.763088241472765j)),
 ((\PYGZhy{}4, 0), (\PYGZhy{}21.092399479624063\PYGZhy{}7.428119584083979j)),
 ((3, \PYGZhy{}2), (18.046523876827386+2.5971752659760368j)),
 ((3, \PYGZhy{}2), (18.046523876827386+2.5971752659760368j)),
 ((\PYGZhy{}3, \PYGZhy{}2), (18.59914527451261+7.6023610122723255j)),
 ((0, 2), (45.25288306329196\PYGZhy{}3.200855947045237j)),
 ((2, 4), (\PYGZhy{}11.797382443780851+1.8726152619466332j)),
 ((\PYGZhy{}3, \PYGZhy{}2), (18.59914527451261+7.6023610122723255j)),
 ((\PYGZhy{}3, 4), (10.97997772948687+0.8737280514156963j)),
 ((\PYGZhy{}4, 2), (\PYGZhy{}11.05946261320548+0.4895276507069246j)),
 ((2, \PYGZhy{}4), (\PYGZhy{}11.158564582308404+2.58553536706419j)),
 ((4, 0), (\PYGZhy{}21.092399479624063+7.428119584083978j)),
 ((2, \PYGZhy{}4), (\PYGZhy{}11.158564582308404+2.58553536706419j)),
 ((\PYGZhy{}3, 0), (9.345246066663236+12.763088241472765j)),
 ((4, 1), (16.740754111448133+2.309720618467048j)),
 ((\PYGZhy{}4, 2), (\PYGZhy{}11.05946261320548+0.4895276507069246j)),
 ((1, 3), (\PYGZhy{}11.35613468978443+3.361553558377294j))]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
It is important to note here that the data points in data\_list is complex. Since we sampled from the fourier transform, we have no need to calcuate the data term like we do in the loss function above. Below is a altered version of the loss function above.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Assumption image is 80px by 80px =\PYGZgt{} 6400 variables}
\PYG{k}{def} \PYG{n+nf}{simple\PYGZus{}loss}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{:} \PYG{n+nb}{list}\PYG{p}{[}\PYG{n}{data}\PYG{p}{]}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{p} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{reg\PYGZus{}weight} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{FOV} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{}Ask about u.rad}
    \PYG{n}{error\PYGZus{}sum} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{n}{vis\PYGZus{}images} \PYG{o}{=} \PYG{n}{interpolate}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{FOV}\PYG{p}{)}

    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{vis\PYGZus{}data} \PYG{o}{=} \PYG{n}{data\PYGZus{}list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
        \PYG{n}{vis\PYGZus{}image} \PYG{o}{=} \PYG{n}{vis\PYGZus{}images}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
        \PYG{n}{error} \PYG{o}{=} \PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{vis\PYGZus{}image}\PYG{o}{\PYGZhy{}}\PYG{n}{vis\PYGZus{}data}\PYG{p}{)}\PYG{p}{)} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}
        \PYG{n}{error\PYGZus{}sum} \PYG{o}{+}\PYG{o}{=} \PYG{n}{error}
    
    \PYG{k}{return} \PYG{n}{error\PYGZus{}sum}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Finally, below we calcuate the loss of the sample image we started with and then shift the image in all directions. Then we plot the array of losses that we obtained.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{calculate\PYGZus{}losses}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{loss\PYGZus{}arr} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{)}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{image\PYGZus{}1} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{roll}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{,} \PYG{n}{i}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Right shifts}
        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{image\PYGZus{}2} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{roll}\PYG{p}{(}\PYG{n}{image\PYGZus{}1}\PYG{p}{,} \PYG{n}{j}\PYG{p}{,} \PYG{n}{axis} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Up shifts}
            \PYG{n}{loss\PYGZus{}arr}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{simple\PYGZus{}loss}\PYG{p}{(}\PYG{n}{image\PYGZus{}2}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{reg\PYGZus{}weight}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Note here for why we shift}
    \PYG{n}{loss\PYGZus{}arr1} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{roll}\PYG{p}{(}\PYG{n}{loss\PYGZus{}arr}\PYG{p}{,} \PYG{l+m+mi}{40}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{n}{loss\PYGZus{}arr2} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{roll}\PYG{p}{(}\PYG{n}{loss\PYGZus{}arr1}\PYG{p}{,} \PYG{l+m+mi}{40}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}

    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{loss\PYGZus{}arr2}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{loss\PYGZus{}arr}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{loss\PYGZus{}arr} \PYG{o}{=} \PYG{n}{calculate\PYGZus{}losses}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{ac0e3ec4ed17e6365f3c514fc4b50c4c782435036edb7329ce4423b7fe126bc9}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
The dark spots in this picture are low points while the yellow spots are high points. Here we see that there are a few spots where the image produces low loss. If ran again, we will get differing behaviors

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{coords}\PYG{p}{,} \PYG{n}{data\PYGZus{}list} \PYG{o}{=} \PYG{n}{do\PYGZus{}sample}\PYG{p}{(}\PYG{l+m+mi}{25}\PYG{p}{)}
\PYG{n}{loss\PYGZus{}arr} \PYG{o}{=} \PYG{n}{calculate\PYGZus{}losses}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{0690ec2331a658d0b67fbe8dfd12b689c4a77d197453822eb4d97429524d03b8}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{coords}\PYG{p}{,} \PYG{n}{data\PYGZus{}list} \PYG{o}{=} \PYG{n}{do\PYGZus{}sample}\PYG{p}{(}\PYG{l+m+mi}{25}\PYG{p}{)}
\PYG{n}{loss\PYGZus{}arr} \PYG{o}{=} \PYG{n}{calculate\PYGZus{}losses}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{cfa3b61e93225560bce871e78e23a5e09af6847eb65a3d21ec9b2dd9636920d3}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{coords}\PYG{p}{,} \PYG{n}{data\PYGZus{}list} \PYG{o}{=} \PYG{n}{do\PYGZus{}sample}\PYG{p}{(}\PYG{l+m+mi}{25}\PYG{p}{)}
\PYG{n}{loss\PYGZus{}arr} \PYG{o}{=} \PYG{n}{calculate\PYGZus{}losses}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{ea5d73a9a456e40d4b75383898865582bc1edcb20b451a927fe2fea33e65c355}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
In all four of these trials (and other reruns that we test), we generally see dark spots in the centers suggesting that the best area to put the ring is centered in the middle of the image

\sphinxstepscope

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}}\PYG{k}{run} ./utility.ipynb
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\chapter{Gradient Calculations: Finite Differences}
\label{\detokenize{finite_gradient:gradient-calculations-finite-differences}}\label{\detokenize{finite_gradient::doc}}
\sphinxAtStartPar
We have two different methods of computing gradients and in this notebook we will explore the first one.


\section{Gradient’s Background}
\label{\detokenize{finite_gradient:gradient-s-background}}
\sphinxAtStartPar
A gradient is the direction of greatest change when looking at a scalar function. It is usually described as a generalized derivative or the rate of change. In our model, the gradient will be positive or negative depending on if a pixel’s value must in increased or decreased. Additionally, each pixel will have its own gradient.

\sphinxAtStartPar
Here’s an intuitive way of looking at gradients: Image you are standing in Tucson at Alvernon and Grant and we are interested in the function f that tells you your elevation. The gradient of f will always tell you which direction you should travel in in order to rise in elevation the quickest.

\sphinxAtStartPar
Since gradients are consistent (meaning if initial conditions are constant and the function doesn’t change then we always get the same result), we can use gradients to find local maximums and minimums by simply following the gradient until either the gradient is 0 or we never finish (in the event of infinity end behaviors).

\sphinxAtStartPar
Why are gradient’s important? In the real world, gradients are used in many fields like physics, robotics, and optimizations. We use it all the time in order to quanify the net rate of change in multi\sphinxhyphen{}variable functions!


\section{Method one: Finite Differences Methods}
\label{\detokenize{finite_gradient:method-one-finite-differences-methods}}
\sphinxAtStartPar
The Finite Differences Method are a numerical analysis technique for solving differential equations by approximating derivatves using finite differences. Using these finite differences we can approximate a gradient of a function which we will denote as \(\nabla f\).

\sphinxAtStartPar
So what is Finite Differences exactly? It is a mathematical expression of the form \(f(x+b)-f(x+a)\).

\sphinxAtStartPar
There are three basic types that are commonly considered for this method: Forward, Backward, and Central.

\sphinxAtStartPar
Forward differences is calcuated by \(\nabla f = \frac{f(x+h)-f(x)}{h}\)

\sphinxAtStartPar
Backward differences is calcuated by \(\nabla f = \frac{f(x) - f(x-h)}{h}\)

\sphinxAtStartPar
Central differences is calcuated by \(\nabla f = \frac{f(x+\frac{h}{2})-f(x-\frac{h}{2})}{h}\)


\subsection{The Function Implemented}
\label{\detokenize{finite_gradient:the-function-implemented}}
\sphinxAtStartPar
Below we have all three methods implemented controlled by a mode flag.

\sphinxAtStartPar
For Gradient Descent, we consider \(f\) to be our loss function and h to be a minute difference from a pixel’s value. We iterate over every pixel and calculate the loss needed for equation used (\(f(x+h)\), \(f(x-h)\), or \(f(x+\frac{h}{2})-f(x-\frac{h}{2})\)). This gives us the gradient for each pixel.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{gradient\PYGZus{}finite\PYGZus{}differences}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{:} \PYG{n+nb}{list}\PYG{p}{[}\PYG{n}{data}\PYG{p}{]}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{image}\PYG{p}{,} \PYG{n}{mode} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} 0 For central, \PYGZhy{}1 for backward, 1 for forward}
    \PYG{n}{image\PYGZus{}copy} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{subok}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
    \PYG{n}{upper\PYGZus{}diff}\PYG{p}{:} \PYG{n+nb}{float}
    \PYG{n}{lower\PYGZus{}diff}\PYG{p}{:} \PYG{n+nb}{float}
    \PYG{n}{h}\PYG{p}{:} \PYG{n+nb}{float}
    \PYG{n}{gradient\PYGZus{}arr} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{p}{,}\PYG{n}{dtype}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{complex\PYGZus{}}\PYG{p}{)}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{mode} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} Central difference}
        \PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{for} \PYG{n}{col} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{image}\PYG{p}{[}\PYG{n}{row}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{image\PYGZus{}copy}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}6} \PYG{o}{/} \PYG{l+m+mi}{2}
                \PYG{n}{upper\PYGZus{}diff} \PYG{o}{=} \PYG{n}{simple\PYGZus{}loss}\PYG{p}{(}\PYG{n}{image\PYGZus{}copy}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{)}
                \PYG{n}{image\PYGZus{}copy}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}6}
                \PYG{n}{lower\PYGZus{}diff} \PYG{o}{=} \PYG{n}{simple\PYGZus{}loss}\PYG{p}{(}\PYG{n}{image\PYGZus{}copy}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{)}
                \PYG{n}{image\PYGZus{}copy}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]} \PYG{o}{=} \PYG{n}{image}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} Reset that pixel to original value}
                \PYG{n}{gradient\PYGZus{}arr}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{n}{upper\PYGZus{}diff} \PYG{o}{\PYGZhy{}} \PYG{n}{lower\PYGZus{}diff}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mf}{1e\PYGZhy{}6}
    \PYG{k}{elif} \PYG{p}{(}\PYG{n}{mode} \PYG{o}{==} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} Backward difference}
        \PYG{n}{upper\PYGZus{}diff} \PYG{o}{=} \PYG{n}{simple\PYGZus{}loss}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{for} \PYG{n}{col} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{image}\PYG{p}{[}\PYG{n}{row}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{image\PYGZus{}copy}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}8}
                \PYG{n}{lower\PYGZus{}diff} \PYG{o}{=} \PYG{n}{simple\PYGZus{}loss}\PYG{p}{(}\PYG{n}{image\PYGZus{}copy}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{)}
                \PYG{n}{gradient\PYGZus{}arr}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{n}{upper\PYGZus{}diff} \PYG{o}{\PYGZhy{}} \PYG{n}{lower\PYGZus{}diff}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mf}{1e\PYGZhy{}8}
                \PYG{n}{image\PYGZus{}copy}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]} \PYG{o}{=} \PYG{n}{image}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]}
    \PYG{k}{elif} \PYG{p}{(}\PYG{n}{mode} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{:} \PYG{c+c1}{\PYGZsh{} Forward difference is default}
        \PYG{n}{lower\PYGZus{}diff} \PYG{o}{=} \PYG{n}{simple\PYGZus{}loss}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{for} \PYG{n}{col} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{image}\PYG{p}{[}\PYG{n}{row}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{image\PYGZus{}copy}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}8} 
                \PYG{n}{upper\PYGZus{}diff} \PYG{o}{=} \PYG{n}{simple\PYGZus{}loss}\PYG{p}{(}\PYG{n}{image\PYGZus{}copy}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{)}
                \PYG{n}{gradient\PYGZus{}arr}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{n}{upper\PYGZus{}diff} \PYG{o}{\PYGZhy{}} \PYG{n}{lower\PYGZus{}diff}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mf}{1e\PYGZhy{}8}
                \PYG{n}{image\PYGZus{}copy}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]} \PYG{o}{=} \PYG{n}{image}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{k}{raise} \PYG{n+ne}{ValueError}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Incorrect mode for finite differences}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{gradient\PYGZus{}arr}\PYG{o}{.}\PYG{n}{real}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Note: We are using “simple\_loss” in this because we are using the synthetic data. For using this on real data, use the “loss” function.

\sphinxAtStartPar
The version in the utility file uses “loss”.


\subsection{Demo Walkthrough}
\label{\detokenize{finite_gradient:demo-walkthrough}}
\sphinxAtStartPar
Start with an empty or blank image

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{emp} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{80}\PYG{p}{,}\PYG{l+m+mi}{80}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{emp}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(\PYGZhy{}0.5, 79.5, 79.5, \PYGZhy{}0.5)
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{50044725cf3b7bb9aba8413280e2b5fac297b8a84f56bbf478d426329bef7e14}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Next we get the sample data points from our synthetic data. Afterwards we will run our gradient code.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sample} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{loadtxt}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{images/data.csv}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{delimiter}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{coords}\PYG{p}{,} \PYG{n}{data\PYGZus{}list} \PYG{o}{=} \PYG{n}{do\PYGZus{}sample}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{gradient\PYGZus{}finite\PYGZus{}differences}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{emp}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(\PYGZhy{}0.5, 79.5, 79.5, \PYGZhy{}0.5)
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{140acf16b5b3e65a9da08d60982d6f98a5dfdb81a134393420c489c3b071a794}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Above is the image representation of the gradient, darker areas represent smaller gradients and lighter areas represent bigger gradients.

\sphinxAtStartPar
It is specifically a gradient when we start our “image” as an empty or blank image. The gradient above shows which pixels are different than what we would expect given a data set (whether some should be brighter, darker or stay the same).


\section{Gradient Descent}
\label{\detokenize{finite_gradient:gradient-descent}}
\sphinxAtStartPar
Now that we have computed a gradient, we can now start doing gradient descent. Gradient Descent is an optimization algorithm for finding local minimum within a differentiable function. We can use this to find values of parameters that minimize some sort of cost function. Here, the parameters as simply each pixel in our image, and the cost functions that we are trying to minimize is the loss function.

\sphinxAtStartPar
Heres how it works. We first calcualte the loss at the current position. The algorithm then iteratively calculates the next image by using the gradient at the current position. We scale the gradient so that we can obtain a loss less than the current loss and then subtract the scaled gradient from the image. This is called a single step. We subtract the gradient because we are looking to minimise the function rather than maximizing it.

\sphinxAtStartPar
We take a bunch of these steps until we hit some stopping condition (here it is np.min(np.abs(grad)) \(\leq\) 0.0000001).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{gradient\PYGZus{}descent}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{subset\PYGZus{}percent} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{image\PYGZus{}copy} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{subok}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Uses copy of the image due to lists being mutable in python}
    \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{n}{grad} \PYG{o}{=} \PYG{k+kc}{None}
    \PYG{c+c1}{\PYGZsh{} Can also use max here, min just makes it finish quicker}
    \PYG{k}{while} \PYG{n}{grad} \PYG{o+ow}{is} \PYG{k+kc}{None} \PYG{o+ow}{or} \PYG{n}{np}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{grad}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{0.0000001}\PYG{p}{:}

        \PYG{n}{t} \PYG{o}{=} \PYG{l+m+mi}{10000000} \PYG{c+c1}{\PYGZsh{} Initial Step size which resets each iteration}
        \PYG{n}{prev\PYGZus{}loss} \PYG{o}{=} \PYG{n}{simple\PYGZus{}loss}\PYG{p}{(}\PYG{n}{image\PYGZus{}copy}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{)}
        \PYG{n}{grad} \PYG{o}{=} \PYG{n}{gradient\PYGZus{}finite\PYGZus{}differences}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{image\PYGZus{}copy}\PYG{p}{)}

        \PYG{n}{new\PYGZus{}image} \PYG{o}{=} \PYG{n}{image\PYGZus{}copy} \PYG{o}{\PYGZhy{}} \PYG{n}{t} \PYG{o}{*} \PYG{n}{grad}\PYG{o}{.}\PYG{n}{real}
        \PYG{n}{new\PYGZus{}loss} \PYG{o}{=} \PYG{n}{simple\PYGZus{}loss}\PYG{p}{(}\PYG{n}{new\PYGZus{}image}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{)}
        
        \PYG{k}{while} \PYG{n}{new\PYGZus{}loss} \PYG{o}{\PYGZgt{}} \PYG{n}{prev\PYGZus{}loss}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} Only run when new\PYGZus{}loss \PYGZgt{} prev\PYGZus{}loss}
            \PYG{n}{new\PYGZus{}image} \PYG{o}{=} \PYG{n}{image\PYGZus{}copy} \PYG{o}{\PYGZhy{}} \PYG{n}{t} \PYG{o}{*} \PYG{n}{grad}\PYG{o}{.}\PYG{n}{real}
            \PYG{n}{new\PYGZus{}loss} \PYG{o}{=} \PYG{n}{simple\PYGZus{}loss}\PYG{p}{(}\PYG{n}{new\PYGZus{}image}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{)}
            \PYG{n}{t} \PYG{o}{/}\PYG{o}{=} \PYG{l+m+mi}{2}

        \PYG{n}{image\PYGZus{}copy} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{t} \PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{grad}\PYG{o}{.}\PYG{n}{real} \PYG{c+c1}{\PYGZsh{} Multiply by 2 to undo last divide in the while loop}
        \PYG{n}{i} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
        \PYG{k}{if} \PYG{n}{i} \PYG{o}{==} \PYG{l+m+mi}{1000}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} Hard stop here for notebook purposes}
            \PYG{k}{return} \PYG{n}{image\PYGZus{}copy}
    \PYG{k}{return} \PYG{n}{image\PYGZus{}copy}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Here is what the gradient descent’s output looks like after 1000 iterations. The code should be ran using

\begin{sphinxVerbatim}[commandchars=\\\{\}]
reconstructed\PYGZus{}img = gradient\PYGZus{}descent(emp, data\PYGZus{}list, coords)
\end{sphinxVerbatim}

\sphinxAtStartPar
The code isn’t ran here because the notebook doesn’t allow for something to run for extended periods of time (upwards of 10 min).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{reconstructed\PYGZus{}img} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{loadtxt}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{images/reconstructed\PYGZus{}img.csv}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{delimiter}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{reconstructed\PYGZus{}img}\PYG{p}{,} \PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{vmax}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(\PYGZhy{}0.5, 79.5, 79.5, \PYGZhy{}0.5)
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{40c73ef4ff914f319a1c172d64871a9423b259d2d88b1fc000cb3b76e8897447}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{vmax}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(\PYGZhy{}0.5, 79.5, 79.5, \PYGZhy{}0.5)
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{9be258954c7ea249931137efd059cc2c351f3e7463876f4cca4282d2f0c136de}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Here is the original image that the data was taken from

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{,} \PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{vmax}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(\PYGZhy{}0.5, 79.5, 79.5, \PYGZhy{}0.5)
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{fc08e6a8f5512daa0bbd5ea544b51054b7c9fd38f066d5fc509489e399a9229e}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
As you can see here, the reconstructed image doesn’t replicate the original image directly but it will still reconstruct some of the big important features that EHT Analysis uses. Here we can see the general shape of the reconstructed image matches up with the original image

\sphinxstepscope

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}}\PYG{k}{run} ./utility.ipynb
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\chapter{Gradient Calculations: “Dirtying” the Image}
\label{\detokenize{dirty_gradient:gradient-calculations-dirtying-the-image}}\label{\detokenize{dirty_gradient::doc}}

\section{Method two: Dirtying the Image}
\label{\detokenize{dirty_gradient:method-two-dirtying-the-image}}
\sphinxAtStartPar
Here, we use a different method of computing gradients in order to speed up the gradient calculation process. By doing so, we should also see an increase in speed for the gradient descent.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sample} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{loadtxt}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{images/data.csv}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{delimiter}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{coords}\PYG{p}{,} \PYG{n}{data\PYGZus{}list} \PYG{o}{=} \PYG{n}{do\PYGZus{}sample}\PYG{p}{(}\PYG{l+m+mi}{25}\PYG{p}{)}
\PYG{n}{emp} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{80}\PYG{p}{,}\PYG{l+m+mi}{80}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Here we calculate gradient using some preprocessing and derivatives. We also reduce time by using a selection approach.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{preprocess\PYGZus{}gradient}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{image}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{r}\PYG{p}{,} \PYG{n}{c} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}
    \PYG{n}{preprocessed} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{[}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{complex\PYGZus{}}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{col} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{image}\PYG{p}{[}\PYG{n}{row}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{for} \PYG{n}{datum} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{term} \PYG{o}{=} \PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{*}\PYG{l+m+mi}{1}\PYG{n}{j}\PYG{p}{)}\PYG{o}{/}\PYG{n}{image}\PYG{o}{.}\PYG{n}{size}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n}{row}\PYG{o}{*}\PYG{n}{coords}\PYG{p}{[}\PYG{n}{datum}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{n}{col}\PYG{o}{*}\PYG{n}{coords}\PYG{p}{[}\PYG{n}{datum}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}.size for numpy array returns \PYGZsh{} of rows * \PYGZsh{} of cols}
                \PYG{n}{term\PYGZus{}1} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{term}\PYG{p}{)}
                \PYG{n}{term\PYGZus{}2} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{term}\PYG{p}{)}
                \PYG{n}{preprocessed}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{,}\PYG{n}{datum}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{term\PYGZus{}1}
                \PYG{n}{preprocessed}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{,}\PYG{n}{datum}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{term\PYGZus{}2}
    \PYG{k}{return} \PYG{n}{preprocessed}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{coeffs} \PYG{o}{=} \PYG{n}{preprocess\PYGZus{}gradient}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{emp}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{dirty\PYGZus{}gradient}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{:} \PYG{n+nb}{list}\PYG{p}{[}\PYG{n}{data}\PYG{p}{]}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{coeffs}\PYG{p}{,} \PYG{n}{image}\PYG{p}{,} \PYG{n}{subset\PYGZus{}percent} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{FOV} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{o}{*}\PYG{n}{u}\PYG{o}{.}\PYG{n}{uas}\PYG{o}{.}\PYG{n}{to}\PYG{p}{(}\PYG{n}{u}\PYG{o}{.}\PYG{n}{rad}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{gradient\PYGZus{}arr} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Because we are in real space}
    \PYG{n}{vis\PYGZus{}images} \PYG{o}{=} \PYG{n}{interpolate}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{FOV}\PYG{p}{)}
    \PYG{n}{selection} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{choice}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{size}\PYG{o}{=}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{coords}\PYG{p}{)}\PYG{o}{*}\PYG{n}{subset\PYGZus{}percent}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{n}{replace}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} selection is full of indicies}
    \PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{col} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{image}\PYG{p}{[}\PYG{n}{row}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{gradient\PYGZus{}sum} \PYG{o}{=} \PYG{l+m+mi}{0}
            \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{selection}\PYG{p}{:}
                \PYG{n}{vis\PYGZus{}data} \PYG{o}{=} \PYG{n}{data\PYGZus{}list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{vis\PYGZus{}data}
                \PYG{n}{vis\PYGZus{}image} \PYG{o}{=} \PYG{n}{vis\PYGZus{}images}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
                \PYG{n}{term\PYGZus{}1} \PYG{o}{=} \PYG{n}{coeffs}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{,}\PYG{n}{i}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{*} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{n}{vis\PYGZus{}image}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{n}{vis\PYGZus{}data}\PYG{p}{)}\PYG{p}{)}
                \PYG{n}{term\PYGZus{}2} \PYG{o}{=} \PYG{n}{coeffs}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{,}\PYG{n}{i}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{*} \PYG{p}{(}\PYG{n}{vis\PYGZus{}image} \PYG{o}{\PYGZhy{}} \PYG{n}{vis\PYGZus{}data}\PYG{p}{)}
                \PYG{n}{gradient\PYGZus{}sum} \PYG{o}{+}\PYG{o}{=} \PYG{p}{(}\PYG{n}{term\PYGZus{}1} \PYG{o}{+} \PYG{n}{term\PYGZus{}2}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{sigma} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{)}
            \PYG{n}{gradient\PYGZus{}arr}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]} \PYG{o}{=} \PYG{n}{gradient\PYGZus{}sum}
    \PYG{k}{return} \PYG{n}{gradient\PYGZus{}arr}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{dirty\PYGZus{}gradient\PYGZus{}simple}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{:} \PYG{n+nb}{list}\PYG{p}{[}\PYG{n}{data}\PYG{p}{]}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{coeffs}\PYG{p}{,} \PYG{n}{image}\PYG{p}{,} \PYG{n}{subset\PYGZus{}percent} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{FOV} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{o}{*}\PYG{n}{u}\PYG{o}{.}\PYG{n}{uas}\PYG{o}{.}\PYG{n}{to}\PYG{p}{(}\PYG{n}{u}\PYG{o}{.}\PYG{n}{rad}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{gradient\PYGZus{}arr} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Because we are in real space}
    \PYG{n}{vis\PYGZus{}images} \PYG{o}{=} \PYG{n}{interpolate}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{FOV}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{} selection = np.random.choice(np.arange(len(data\PYGZus{}list)), size=len(coords)*subset\PYGZus{}percent//100, replace=False) \PYGZsh{} selection is full of indicies}
    \PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{col} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{image}\PYG{p}{[}\PYG{n}{row}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{gradient\PYGZus{}sum} \PYG{o}{=} \PYG{l+m+mi}{0}
            \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{vis\PYGZus{}data} \PYG{o}{=} \PYG{n}{data\PYGZus{}list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
                \PYG{n}{vis\PYGZus{}image} \PYG{o}{=} \PYG{n}{vis\PYGZus{}images}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
                \PYG{n}{term\PYGZus{}1} \PYG{o}{=} \PYG{n}{coeffs}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{,}\PYG{n}{i}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{*} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{n}{vis\PYGZus{}image}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{n}{vis\PYGZus{}data}\PYG{p}{)}\PYG{p}{)}
                \PYG{n}{term\PYGZus{}2} \PYG{o}{=} \PYG{n}{coeffs}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{,}\PYG{n}{i}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{*} \PYG{p}{(}\PYG{n}{vis\PYGZus{}image} \PYG{o}{\PYGZhy{}} \PYG{n}{vis\PYGZus{}data}\PYG{p}{)}
                \PYG{n}{gradient\PYGZus{}sum} \PYG{o}{+}\PYG{o}{=} \PYG{p}{(}\PYG{n}{term\PYGZus{}1} \PYG{o}{+} \PYG{n}{term\PYGZus{}2}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} What should I set sigma to?}
            \PYG{n}{gradient\PYGZus{}arr}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]} \PYG{o}{=} \PYG{n}{gradient\PYGZus{}sum}
    \PYG{k}{return} \PYG{n}{gradient\PYGZus{}arr}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{n}{dirty\PYGZus{}gradient\PYGZus{}simple}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{coeffs}\PYG{p}{,} \PYG{n}{emp}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
/var/folders/\PYGZus{}b/trlmhkgj5xq968yccj4vtg1c0000gn/T/ipykernel\PYGZus{}69440/1027418742.py:14: ComplexWarning: Casting complex values to real discards the imaginary part
  gradient\PYGZus{}arr[row,col] = gradient\PYGZus{}sum
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(\PYGZhy{}0.5, 79.5, 79.5, \PYGZhy{}0.5)
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{1d40cec58b8e3879af820a6ff3a8c7619227971ad7c70e496c5d3000cce1fa41}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{gradient\PYGZus{}descent}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{coeffs}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{image\PYGZus{}copy} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{subok}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Uses copy of the image due to lists being mutable in python}
    \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{n}{grad} \PYG{o}{=} \PYG{k+kc}{None}
    \PYG{c+c1}{\PYGZsh{} Can also use max here, min just makes it finish quicker}
    \PYG{k}{while} \PYG{n}{grad} \PYG{o+ow}{is} \PYG{k+kc}{None} \PYG{o+ow}{or} \PYG{n}{np}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{grad}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{0.0000001}\PYG{p}{:}

        \PYG{n}{t} \PYG{o}{=} \PYG{l+m+mi}{10000000} \PYG{c+c1}{\PYGZsh{} Initial Step size which resets each iteration}
        \PYG{n}{prev\PYGZus{}loss} \PYG{o}{=} \PYG{n}{simple\PYGZus{}loss}\PYG{p}{(}\PYG{n}{image\PYGZus{}copy}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{)}
        \PYG{n}{grad} \PYG{o}{=} \PYG{n}{dirty\PYGZus{}gradient\PYGZus{}simple}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{coeffs}\PYG{p}{,} \PYG{n}{image\PYGZus{}copy}\PYG{p}{)}

        \PYG{n}{new\PYGZus{}image} \PYG{o}{=} \PYG{n}{image\PYGZus{}copy} \PYG{o}{\PYGZhy{}} \PYG{n}{t} \PYG{o}{*} \PYG{n}{grad}\PYG{o}{.}\PYG{n}{real}
        \PYG{n}{new\PYGZus{}loss} \PYG{o}{=} \PYG{n}{simple\PYGZus{}loss}\PYG{p}{(}\PYG{n}{new\PYGZus{}image}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{)}
        
        \PYG{k}{while} \PYG{n}{new\PYGZus{}loss} \PYG{o}{\PYGZgt{}} \PYG{n}{prev\PYGZus{}loss}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} Only run when new\PYGZus{}loss \PYGZgt{} prev\PYGZus{}loss}
            \PYG{n}{new\PYGZus{}image} \PYG{o}{=} \PYG{n}{image\PYGZus{}copy} \PYG{o}{\PYGZhy{}} \PYG{n}{t} \PYG{o}{*} \PYG{n}{grad}\PYG{o}{.}\PYG{n}{real}
            \PYG{n}{new\PYGZus{}loss} \PYG{o}{=} \PYG{n}{simple\PYGZus{}loss}\PYG{p}{(}\PYG{n}{new\PYGZus{}image}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{)}
            \PYG{n}{t} \PYG{o}{/}\PYG{o}{=} \PYG{l+m+mi}{2}

        \PYG{n}{image\PYGZus{}copy} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{t} \PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{grad}\PYG{o}{.}\PYG{n}{real} \PYG{c+c1}{\PYGZsh{} Multiply by 2 to undo last divide in the while loop}
        \PYG{n}{i} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
        \PYG{k}{if} \PYG{n}{i} \PYG{o}{==} \PYG{l+m+mi}{1000}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} Hard stop here for notebook purposes}
            \PYG{k}{return} \PYG{n}{image\PYGZus{}copy}
    \PYG{k}{return} \PYG{n}{image\PYGZus{}copy}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}x = gradient\PYGZus{}descent(emp,data\PYGZus{}list,coords,coeffs)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(\PYGZhy{}0.5, 79.5, 79.5, \PYGZhy{}0.5)
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{1d40cec58b8e3879af820a6ff3a8c7619227971ad7c70e496c5d3000cce1fa41}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}






\renewcommand{\indexname}{Index}
\printindex
\end{document}