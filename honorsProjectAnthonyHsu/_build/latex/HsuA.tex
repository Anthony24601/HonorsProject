%% Generated by Sphinx.
\def\sphinxdocclass{jupyterBook}
\documentclass[letterpaper,10pt,english]{jupyterBook}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}
%% memoir class requires extra handling
\makeatletter\@ifclassloaded{memoir}
{\ifdefined\memhyperindexfalse\memhyperindexfalse\fi}{}\makeatother

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\defaultfontfeatures[\rmfamily,\sffamily,\ttfamily]{}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}



\setmainfont{FreeSerif}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Italic,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldItalic
]
\setsansfont{FreeSans}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]
\setmonofont{FreeMono}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]



\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}



        % Start of preamble defined in sphinx-jupyterbook-latex %
         \usepackage[Latin,Greek]{ucharclasses}
        \usepackage{unicode-math}
        % fixing title of the toc
        \addto\captionsenglish{\renewcommand{\contentsname}{Contents}}
        \hypersetup{
            pdfencoding=auto,
            psdextra
        }
        % End of preamble defined in sphinx-jupyterbook-latex %
        

\title{Exploring Gradient Descent On Image Reconstruction with EHT data}
\date{May 01, 2024}
\release{}
\author{Anthony Hsu}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{intro::doc}}


\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\Large Exploring Gradient Descent On Image Reconstruction with EHT data}
\end{DUlineblock}

\sphinxAtStartPar
Abstract:
The Event Horizon Telescope (EHT) has revolutionized our understanding of black holes by using Very Long Baseline Interferometry (VLBI) to reconstruct the highest resolution images of black holes. It combines data from a global network of radio telescopes to observe the immediate surroundings of black holes, particularly focusing on the supermassive black hole in the galaxy M87 and the center of our Milky Way. This Jupyter Book explores the intricate process of image reconstruction from EHT data, highlighting several critical aspects such as interpolation, loss calculation, and gradient computation methods.

\sphinxAtStartPar
Interpolation schemes play a pivotal role in connecting the snap averaged data in EHT’s sparse observation and reconstructing an image. By examining the relationship between the image and Fourier domains, we gain insights into the factors influencing high\sphinxhyphen{}resolution image recreation. One approach to image reconstruction involves creating a loss function and minimizing it. The loss function quantifies how well the image matches the observational data and how same or expected the appearance of the image looks. The latter part of a loss function is called a regularizer. The optimum (the best performing image) is accepted as the image reconstruction of the data.

\sphinxAtStartPar
Additionally, this notebook assesses two distinct methods for computing gradients: finite differences and an “dirtying the image” approach. By comparing their efficiency and accuracy, we aim to offer guidance on selecting appropriate gradient computation methods for image reconstruction tasks. Integrating these components, we perform gradient descent on sample test images to demonstrate practical applications of these theories.
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{data::doc}]{\sphinxcrossref{Intro and Setup Use Diff}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{interpolation::doc}]{\sphinxcrossref{Interpolation and Regularizers}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{loss::doc}]{\sphinxcrossref{Loss}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{finite_gradient::doc}]{\sphinxcrossref{Gradient Calculations: Finite Differences}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{dirty_gradient::doc}]{\sphinxcrossref{Gradient Calculations: “Dirtying” the Image}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{utility::doc}]{\sphinxcrossref{Utility Appendix}}}

\end{itemize}

\sphinxstepscope


\chapter{Intro and Setup Use Diff}
\label{\detokenize{data:intro-and-setup-use-diff}}\label{\detokenize{data::doc}}
\sphinxAtStartPar
These are all the libraries that are needed

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{cmath}
\PYG{k+kn}{import} \PYG{n+nn}{math}
\PYG{k+kn}{from} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{optimize} \PYG{k+kn}{import} \PYG{n}{fmin}\PYG{p}{,} \PYG{n}{minimize}
\PYG{k+kn}{from} \PYG{n+nn}{astropy} \PYG{k+kn}{import} \PYG{n}{units} \PYG{k}{as} \PYG{n}{u}
\PYG{k+kn}{from} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{interpolate} \PYG{k+kn}{import} \PYG{n}{RegularGridInterpolator}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{import} \PYG{n+nn}{copy}
\PYG{o}{\PYGZpc{}}\PYG{k}{matplotlib} inline
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Data Details}
\label{\detokenize{data:data-details}}
\sphinxAtStartPar
In order to capture the image and data of a black hole, we would need a telescope the size of the earth! Although we don’t have one of those, the Event Horizon Telescope were still able to obtain some data about black holes by using a technology called Very Long Baseline Interferometry (VLBI). This involves having many telescope around the world. This in turn creates a virtual telescope and allows us to capture the image of the black hole’s silouette. They are the only ones in the world to do so!

\sphinxAtStartPar
Most of the optics like cameras and cellphones, they don’t hit a limit called the Defraction Limit. This limit is the point at which two Airy patterns are no longer distinguishable from each other and is often known as the cutoff frequence of a lens. Since EHT wants to image things that are extremely far away, they are constantly working at the Defraction limit and are limited by the physics of light.

\sphinxAtStartPar
Because of these limitations, EHT is only able to collect sparse data in the Fourier domain (rather than an actually picture image). Thus in order to obtain a picture, we must do a image reconstruction as an optimization problem in order to fill in the gaps. The data set comes from EHT (The Event Horizon Telescope) and from the HOPS pipeline (software from MIT).


\section{Some Details about the Table}
\label{\detokenize{data:some-details-about-the-table}}
\sphinxAtStartPar
time is the time that it was taken. This time stamp is not used because we assume things are static.

\sphinxAtStartPar
T1 and T2 are the two telescopes.

\sphinxAtStartPar
U and V are the Fourier location of the Fourier domain. They are given in terms of wavelengths (lambda).

\sphinxAtStartPar
Iamp is the Amplitude of the Fourier Coefficient

\sphinxAtStartPar
IPhase is the Phase of the Fourier Coefficient in degrees

\sphinxAtStartPar
ISigma is the estimated magnitude of the error or the noisiness of the data point

\sphinxAtStartPar
Here, we will start to preprocess the data. First we will create a class to hold the information is a more accessible manner

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{data}\PYG{p}{:}
    \PYG{n}{u}\PYG{p}{:} \PYG{n+nb}{float}
    \PYG{n}{v}\PYG{p}{:} \PYG{n+nb}{float}
    \PYG{n}{phase}\PYG{p}{:} \PYG{n+nb}{float}
    \PYG{n}{amp}\PYG{p}{:} \PYG{n+nb}{float}
    \PYG{n}{sigma}\PYG{p}{:} \PYG{n+nb}{float}
    \PYG{n}{vis\PYGZus{}data}\PYG{p}{:} \PYG{n+nb}{complex}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{phase}\PYG{p}{,} \PYG{n}{amp}\PYG{p}{,} \PYG{n}{sigma}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{u} \PYG{o}{=} \PYG{n}{u}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{v} \PYG{o}{=} \PYG{n}{v}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{phase} \PYG{o}{=} \PYG{n}{phase}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{amp} \PYG{o}{=} \PYG{n}{amp}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{sigma} \PYG{o}{=} \PYG{n}{sigma}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{vis\PYGZus{}data} \PYG{o}{=} \PYG{n}{amp} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{n}{j} \PYG{o}{*} \PYG{n}{math}\PYG{o}{.}\PYG{n}{radians}\PYG{p}{(}\PYG{n}{phase}\PYG{p}{)}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}repr\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{[u: }\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{u}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{, v: }\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{v}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{]}\PYG{l+s+s2}{\PYGZdq{}}

    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}str\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{[u: }\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{u}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{, v: }\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{v}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{]}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
The next few cells read the data from a csv file

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{process\PYGZus{}data}\PYG{p}{(}\PYG{n}{data\PYGZus{}df}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Processes the data in the dataframe into a coords list and data objects}
\PYG{l+s+sd}{    Args:}
\PYG{l+s+sd}{        data\PYGZus{}df is a pandas data frame of the data}
\PYG{l+s+sd}{    Returns:}
\PYG{l+s+sd}{        a list of coordinates in u,v space}
\PYG{l+s+sd}{        a list of data objects}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}

    \PYG{n}{coords} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{data\PYGZus{}list} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{data\PYGZus{}df}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{data\PYGZus{}list}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{data}\PYG{p}{(}\PYG{n}{data\PYGZus{}df}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{U(lambda)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{data\PYGZus{}df}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{V(lambda)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{data\PYGZus{}df}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Iphase(d)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{data\PYGZus{}df}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Iamp(Jy)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{data\PYGZus{}df}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Isigma(Jy)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{coords}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{[}\PYG{n}{data\PYGZus{}df}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{U(lambda)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{data\PYGZus{}df}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{V(lambda)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{coords} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{coords}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{read\PYGZus{}data}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    reads the data from a file into a pandas dataframe}
\PYG{l+s+sd}{    Args:}
\PYG{l+s+sd}{        filename is a string that represents a csv file}
\PYG{l+s+sd}{    Returns:}
\PYG{l+s+sd}{        a pandas dataframe}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{read\PYGZus{}csv}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{df}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df} \PYG{o}{=} \PYG{n}{read\PYGZus{}data}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./data/SR1\PYGZus{}M87\PYGZus{}2017\PYGZus{}095\PYGZus{}hi\PYGZus{}hops\PYGZus{}netcal\PYGZus{}StokesI.csv}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{coords}\PYG{p}{,} \PYG{n}{data\PYGZus{}list} \PYG{o}{=} \PYG{n}{process\PYGZus{}data}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\PYG{n}{df}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
      \PYGZsh{}time(UTC)  T1  T2     U(lambda)     V(lambda)  Iamp(Jy)  Iphase(d)  \PYGZbs{}
0       0.768056  AA  LM  1.081710e+09 \PYGZhy{}3.833722e+09  0.014292  \PYGZhy{}118.9454   
1       0.768056  AA  PV \PYGZhy{}4.399933e+09 \PYGZhy{}4.509480e+09  0.136734     5.8638   
2       0.768056  AA  AP  8.349088e+05 \PYGZhy{}1.722271e+06  1.119780    58.1095   
3       0.768056  AP  LM  1.080840e+09 \PYGZhy{}3.832004e+09  0.018448  \PYGZhy{}137.6802   
4       0.768056  AP  PV \PYGZhy{}4.400757e+09 \PYGZhy{}4.507747e+09  0.139619   \PYGZhy{}57.1724   
...          ...  ..  ..           ...           ...       ...        ...   
6453    8.165278  AZ  LM \PYGZhy{}1.078324e+09  1.029597e+09  0.315983    10.9377   
6454    8.165278  AZ  JC  3.392180e+09  9.968579e+08  0.058864    46.0474   
6455    8.165278  JC  LM \PYGZhy{}4.470504e+09  3.273711e+07  0.108582  \PYGZhy{}178.7050   
6456    8.165278  JC  SM  1.745735e+04 \PYGZhy{}1.192282e+05  1.123722   \PYGZhy{}29.5589   
6457    8.165278  LM  SM  4.470522e+09 \PYGZhy{}3.285633e+07  0.104931    96.6936   

      Isigma(Jy)  
0       0.005847  
1       0.004968  
2       0.005243  
3       0.044576  
4       0.032591  
...          ...  
6453    0.030449  
6454    0.090288  
6455    0.043965  
6456    0.091870  
6457    0.028783  

[6458 rows x 8 columns]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Below is EHT’s reconstruction of the data above

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{file} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{images/3597\PYGZus{}blur\PYGZus{}avg.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{r}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{lines} \PYG{o}{=} \PYG{n}{file}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{image} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{180}\PYG{p}{,}\PYG{l+m+mi}{180}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{t} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{lines}\PYG{p}{:}
    \PYG{n}{coord} \PYG{o}{=} \PYG{n}{line}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{x} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{coord}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{1000000}\PYG{p}{)}
    \PYG{n}{y} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{coord}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{1000000}\PYG{p}{)}
    \PYG{n}{z} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{coord}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{10000000000}\PYG{p}{)}
    \PYG{n}{image}\PYG{p}{[}\PYG{n}{x}\PYG{o}{+}\PYG{l+m+mi}{90}\PYG{p}{]}\PYG{p}{[}\PYG{n}{y}\PYG{o}{+}\PYG{l+m+mi}{90}\PYG{p}{]} \PYG{o}{=} \PYG{n}{z}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(\PYGZhy{}0.5, 179.5, 179.5, \PYGZhy{}0.5)
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{dce7dafd214477f1739ab7335fe133516148f92841137ae0ca457ded5c0e1c46}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
And here is what the data looks like in the Fourier Domain

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{FOV}\PYG{o}{=}\PYG{l+m+mi}{180}\PYG{o}{*}\PYG{n}{u}\PYG{o}{.}\PYG{n}{uas}\PYG{o}{.}\PYG{n}{to}\PYG{p}{(}\PYG{n}{u}\PYG{o}{.}\PYG{n}{rad}\PYG{p}{)}
\PYG{n}{kx\PYGZus{}1} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{/}\PYG{n}{FOV}

\PYG{n}{x}\PYG{p}{,}\PYG{n}{y} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{data} \PYG{o+ow}{in} \PYG{n}{data\PYGZus{}list}\PYG{p}{:}
    \PYG{n}{x}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{(}\PYG{n}{data}\PYG{o}{.}\PYG{n}{u}\PYG{o}{/}\PYG{n}{kx\PYGZus{}1}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{y}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{data}\PYG{o}{.}\PYG{n}{v}\PYG{o}{/}\PYG{n}{kx\PYGZus{}1}\PYG{p}{)}

\PYG{n}{ft\PYGZus{}image} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fftshift}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fft2}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{color}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{red}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{s}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{u (\PYGZdl{}10\PYGZca{}9\PYGZdl{})}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{v (\PYGZdl{}10\PYGZca{}9\PYGZdl{})}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{gca}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{set\PYGZus{}aspect}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{equal}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{d37b43258d0702c835a70634d4e791057dfdbff967c0620e7ee7a725fb5ee7a9}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\chapter{Interpolation and Regularizers}
\label{\detokenize{interpolation:interpolation-and-regularizers}}\label{\detokenize{interpolation::doc}}
\sphinxAtStartPar
In this notebook, we will talk about interpolating coordinate values from an image as well as calculating the regularizer
for gradient descent.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}}\PYG{k}{run} ./utility.ipynb
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Background on FOV and k\sphinxhyphen{}space}
\label{\detokenize{interpolation:background-on-fov-and-k-space}}
\sphinxAtStartPar
FOV stands for Field Of View and it refers to the angle over which an image is acquired or displayed. These images are usually captured by some sort of signal processing like telescopes and MRIs. The number of pixels determine the number of units in the Fourier domain that must be obtained in order to reconstruct an image.

\sphinxAtStartPar
For the sakes of this research and example, FOVx = FOVy = FOV and k is the wavenumber which represents the number of wave cycles per unit length. Lets find the value of k in terms of FOV.

\sphinxAtStartPar
In these notebooks we are using discrete Fourier Transform in order to convert from real space to the Fourier domain. We are thinking of the FOV by FOV as a 2\sphinxhyphen{}dimensional torus where everything is periodic on it. The Fourier Transform then performs a function on the torus, the lowest harmonic would be related to sin or cos with the lowest possible frequency so that it is still periodically on the torus. When chooseing a k, if k is too small, then there will be less than one wavelength along the torus.

\sphinxAtStartPar
Here we will define the Fourier transform to be
\begin{equation*}
\begin{split}\hat{f}(n,m) = \int_0^{FOV} \int_0^{FOV} f(x,y)e^{2\pi i \Delta k n x + 2\pi i \Delta k m y} dx dy\end{split}
\end{equation*}
\sphinxAtStartPar
Ideally, we would like w to be the period of the smallest harmonic in one direction. Thus we look at \(\sin 2\pi \Delta k x\) harmonics. Considering the slowest harmonics, then we let n = 1. As x goes from 0 to FOV, we want to end back at where we started. This means that we want \(2\pi \Delta k FOV = 2\pi\). Thus \(\Delta k = \frac{1}{FOV}\).


\section{Interpolation}
\label{\detokenize{interpolation:interpolation}}
\sphinxAtStartPar
In this notebook, we have an image that is being linearly transformed using a Fourier transform. We do this in order to allow us to use direct comparisons between our image (in real space but being transformed into Fourier space) and the data obtained by the telescopes (which are in the spectral or Fourier domain.)

\sphinxAtStartPar
When doing this transformation, we obtain a grid of points, due to the periodicity of the torus, extracted from the image which do not necessarily line up with the U and V coordinates from the dataset. Therefore, we must interpolate or estimate the values of the data points using existing known points in our grid.

\sphinxAtStartPar
Furthermore, in order to translate correctly from image space to Fourier space, we need to multiply the grids (kx and ky) by k\_FOV. The calculation for this is explained above.

\sphinxAtStartPar
It is important to note that the more grid points we have, the more pixels the image will have. Thus the size of our Fourier Domain is the Number of pixels of the image by k\_FOV. If our FOV is very small, then the width of the Fourier grid becomes large.

\sphinxAtStartPar
Next we want to interpolate the complex value at each coordinate. RegularGridInterpolator however cannot interpolate complex numbers so we interpolate the real and imaginary parts separately and then combined them for the final result.

\sphinxAtStartPar
Finally, we use a linear method for interpolation due to it’s local interpolation scheme. The other schemes that RegularGridInterpolator offers uses a C\textasciicircum{}2\sphinxhyphen{}smooth split which is a non\sphinxhyphen{}local scheme. Since we wanted to optimize the computation time, we chose the linear method.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{FOV}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Interpolates the values of each coordinate in coords in the Fourier domain of image}
\PYG{l+s+sd}{    Args:}
\PYG{l+s+sd}{        image is a 80x80 pixel image that represents our reconstructed image}
\PYG{l+s+sd}{        coords is a list of u,v coordinates that we obtained from our data}
\PYG{l+s+sd}{        FOV is the Field of view from the telescopes. For the EHT data, our FOV is 100 micro ascs.}
\PYG{l+s+sd}{    Returns:}
\PYG{l+s+sd}{        The interpolated values at the coordinates based on image}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}

    \PYG{n}{ft\PYGZus{}image} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fftshift}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fft2}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{p}{)}

    \PYG{n}{k\PYGZus{}FOV} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{FOV}

    \PYG{n}{kx} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fftshift}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fftfreq}\PYG{p}{(}\PYG{n}{ft\PYGZus{}image}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{d} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{p}{(}\PYG{n}{k\PYGZus{}FOV}\PYG{o}{*}\PYG{n}{ft\PYGZus{}image}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{ky} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fftshift}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fftfreq}\PYG{p}{(}\PYG{n}{ft\PYGZus{}image}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{d} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{p}{(}\PYG{n}{k\PYGZus{}FOV}\PYG{o}{*}\PYG{n}{ft\PYGZus{}image}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}

    \PYG{n}{interp\PYGZus{}real} \PYG{o}{=} \PYG{n}{RegularGridInterpolator}\PYG{p}{(}\PYG{p}{(}\PYG{n}{kx}\PYG{p}{,} \PYG{n}{ky}\PYG{p}{)}\PYG{p}{,} \PYG{n}{ft\PYGZus{}image}\PYG{o}{.}\PYG{n}{real}\PYG{p}{,} \PYG{n}{bounds\PYGZus{}error}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{method}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{linear}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{interp\PYGZus{}imag} \PYG{o}{=} \PYG{n}{RegularGridInterpolator}\PYG{p}{(}\PYG{p}{(}\PYG{n}{kx}\PYG{p}{,} \PYG{n}{ky}\PYG{p}{)}\PYG{p}{,} \PYG{n}{ft\PYGZus{}image}\PYG{o}{.}\PYG{n}{imag}\PYG{p}{,} \PYG{n}{bounds\PYGZus{}error}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{method}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{linear}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{n}{real} \PYG{o}{=} \PYG{n}{interp\PYGZus{}real}\PYG{p}{(}\PYG{n}{coords}\PYG{p}{)}
    \PYG{n}{imag} \PYG{o}{=} \PYG{n}{interp\PYGZus{}imag}\PYG{p}{(}\PYG{n}{coords}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{real} \PYG{o}{+} \PYG{n}{imag} \PYG{o}{*} \PYG{l+m+mi}{1}\PYG{n}{j}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Here we do some tests using interp\_real and interp\_imag to verify that they do interpolate a value using a linear scheme. First we start with a very basic 5x5 grid.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}
\PYG{n}{y} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}
\PYG{n}{z} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{]}
\PYG{n}{interp} \PYG{o}{=} \PYG{n}{RegularGridInterpolator}\PYG{p}{(}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}\PYG{p}{,}\PYG{n}{z}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Expected: 1, Actual:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{interp}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Expected: 2.5, Actual:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{interp}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{1.5}\PYG{p}{,}\PYG{l+m+mf}{2.5}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Expected: 1, Actual: [1.]
Expected: 2.5, Actual: [2.5]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Now, here is a test on a Fourier transformed image

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sample} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{loadtxt}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{images/interpolate\PYGZus{}test.csv}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{delimiter}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(\PYGZhy{}0.5, 179.5, 179.5, \PYGZhy{}0.5)
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{dce7dafd214477f1739ab7335fe133516148f92841137ae0ca457ded5c0e1c46}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ft\PYGZus{}image} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fftshift}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fft2}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{interpolated\PYGZus{}points} \PYG{o}{=} \PYG{n}{interpolate}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{,}\PYG{p}{[}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{9.0e+09}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{9.0e+09}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{8.9e+09}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{9.0e+09}\PYG{p}{]} \PYG{p}{,}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{8.95e+09}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{9.0e+09}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}\PYG{l+m+mi}{180}\PYG{o}{*}\PYG{n}{u}\PYG{o}{.}\PYG{n}{uas}\PYG{o}{.}\PYG{n}{to}\PYG{p}{(}\PYG{n}{u}\PYG{o}{.}\PYG{n}{rad}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Expected:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ft\PYGZus{}image}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{Actual:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{interpolated\PYGZus{}points}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{Expected:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ft\PYGZus{}image}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{Actual:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{interpolated\PYGZus{}points}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{Expected: }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{p}{(}\PYG{n}{ft\PYGZus{}image}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{+}\PYG{n}{ft\PYGZus{}image}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{Actual:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{interpolated\PYGZus{}points}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Expected: (3.0000000019953994\PYGZhy{}2.1431905139479568e\PYGZhy{}09j) 
Actual: (\PYGZhy{}335133.52213257825+690198.3841637481j)

Expected: (38.20989061676637+0.6177808031820264j) 
Actual: (\PYGZhy{}231640.3460875617+376131.9723567965j)

Expected:  (20.604945309380888+0.30889040051941796j) 
Actual: (\PYGZhy{}283386.93411007+533165.1782602723j)
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Cubic Splines}
\label{\detokenize{interpolation:cubic-splines}}
\sphinxAtStartPar
Below is an interpolation subroutine written by Misha Stepanov.

\sphinxAtStartPar
The code provides an insight into a local interpolation scheme using 2D cubic splines. It is local in a sense that only 12 grid points around the point at which we are interpolating is used to contribute the the estimation. The code the interpolation is done with data being wrapped into a 2D torus and the xy\sphinxhyphen{}coordinates are supplied assuming that the step of the grid in both the x and y directions are equal to 1.

\sphinxAtStartPar
We call a piece piecewise cubic function a cubic spline if it interpolates a set of data points while also guaranteeing the smoothness at the data points observed. Splining is often used instead of Lagrange polynomial interpolations because it yields similar results and avoids the Runge’s phenomenon for higher degree polynomials.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{cubf1}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{:}
  \PYG{n}{cf1} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{+} \PYG{n}{x} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{o}{*}\PYG{n}{x}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{+} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{n}{y}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{)}
  \PYG{n}{cf2} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{+} \PYG{n}{y} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{o}{*}\PYG{n}{y}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{+} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{n}{x}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{)}
  \PYG{k}{return} \PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{p}{(}\PYG{n}{cf1} \PYG{o}{+} \PYG{n}{cf2}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{cubf2}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{:}
  \PYG{k}{return} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n}{x}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{+} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{n}{y}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{cubic12}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{X}\PYG{p}{)}\PYG{p}{:}
  \PYG{n}{N} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{;}  \PYG{n}{F} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}\PYG{p}{)}
  \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{m} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{mod}\PYG{p}{(}\PYG{n}{X}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{N}\PYG{p}{)}\PYG{p}{;}  \PYG{n}{x}\PYG{p}{,} \PYG{n}{y} \PYG{o}{=} \PYG{n}{m} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{floor}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}
    \PYG{n}{m1}\PYG{p}{,} \PYG{n}{m2} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{floor}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{mod}\PYG{p}{(}\PYG{n}{m} \PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{2.}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{N}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{)}
    \PYG{n}{F}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}  \PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{m1} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{m2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{*}\PYG{n}{cubf1}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}
    \PYG{n}{F}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{m1} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{m2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{*}\PYG{n}{cubf1}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}
    \PYG{n}{F}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{m1} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{m2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*}\PYG{n}{cubf1}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{)}
    \PYG{n}{F}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{m1} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{m2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*}\PYG{n}{cubf1}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{,} \PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{)}
    \PYG{n}{F}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{m1} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{m2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{*}\PYG{n}{cubf2}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}
    \PYG{n}{F}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{m1} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{m2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{o}{*}\PYG{n}{cubf2}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}
    \PYG{n}{F}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{m1}    \PYG{p}{,} \PYG{n}{m2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{*}\PYG{n}{cubf2}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}
    \PYG{n}{F}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{m1} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{m2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{o}{*}\PYG{n}{cubf2}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,} \PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{)}
    \PYG{n}{F}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{m1} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{m2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*}\PYG{n}{cubf2}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{)}
    \PYG{n}{F}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{m1} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{m2}    \PYG{p}{]}\PYG{o}{*}\PYG{n}{cubf2}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}
    \PYG{n}{F}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{m1}    \PYG{p}{,} \PYG{n}{m2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*}\PYG{n}{cubf2}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{,} \PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{)}
    \PYG{n}{F}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{A}\PYG{p}{[}\PYG{n}{m1} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{m2}    \PYG{p}{]}\PYG{o}{*}\PYG{n}{cubf2}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{,} \PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{)}
  \PYG{k}{return} \PYG{n}{F}

\PYG{k}{def} \PYG{n+nf}{func}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{:}
  \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{*}\PYG{n}{x}\PYG{p}{)} \PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{*}\PYG{p}{(}\PYG{n}{x} \PYG{o}{+} \PYG{n}{y}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
  \PYG{n}{x} \PYG{o}{=} \PYG{n}{i} \PYG{o}{/} \PYG{l+m+mf}{10.}
  \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{j} \PYG{o}{/} \PYG{l+m+mf}{10.}
    \PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{func}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}

\PYG{n}{X} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{10000}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10000}\PYG{p}{)}\PYG{p}{:}
  \PYG{n}{X}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{i} \PYG{o}{/} \PYG{l+m+mf}{1000.}
  \PYG{n}{X}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{i} \PYG{o}{/} \PYG{l+m+mf}{2000.}
\PYG{n}{F} \PYG{o}{=} \PYG{n}{cubic12}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{X}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10000}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10000}\PYG{p}{)}\PYG{p}{:}
  \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{X}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{X}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{F}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{func}\PYG{p}{(}\PYG{n}{X}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{/} \PYG{l+m+mf}{10.}\PYG{p}{,} \PYG{n}{X}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{/} \PYG{l+m+mf}{10.}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
9.99
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 4.995 \PYGZhy{}1.0058598083263428 \PYGZhy{}1.0062387310745087
9.991 4.9955 \PYGZhy{}1.0052755185370548 \PYGZhy{}1.0056188621460636
9.992 4.996 \PYGZhy{}1.004690839850659 \PYGZhy{}1.0049981027528014
9.993 4.9965 \PYGZhy{}1.0041057771382442 \PYGZhy{}1.0043764531360648
9.994 4.997 \PYGZhy{}1.0035203352965503 \PYGZhy{}1.0037539135379836
9.995 4.9975 \PYGZhy{}1.0029345192480468 \PYGZhy{}1.0031304842014765
9.996 4.998 \PYGZhy{}1.002348333941004 \PYGZhy{}1.002506165370251
9.997 4.9985 \PYGZhy{}1.001761784349569 \PYGZhy{}1.0018809572888083
9.998 4.999 \PYGZhy{}1.001174875473833 \PYGZhy{}1.0012548602024367
9.999 4.9995 \PYGZhy{}1.0005876123399073 \PYGZhy{}1.0006278743572115
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Regularization}
\label{\detokenize{interpolation:regularization}}
\sphinxAtStartPar
Here we start to calculate regularizers. We do so in order to smooth image and add some bias into the model to prevent it from overfitting the training data. Regularizers allow machine learning models to generalize to new examples that it has not seen during training.

\sphinxAtStartPar
The regularizer below implements a regularization method called “total squared variation.” This method favors smooth edges and is often used for astronomical image reconstruction.

\sphinxAtStartPar
The formula for a TSV regularizer is

\sphinxAtStartPar
\(-\sum_l \sum_m[(I_{l+1,m}-I_{l,m})^2+(I_{l,m+1}-I_{l,m})^2]\)

\sphinxAtStartPar
where l and m are pixel coordinates and I is the image. There are however other similar regularizers like Total variation that favors pixel\sphinxhyphen{}to\sphinxhyphen{}pixel smoothness.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{calc\PYGZus{}regularizer}\PYG{p}{(}\PYG{n}{image}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{,} \PYG{n}{tsv}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{p}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Calculates the regularizer according to total squared variation}
\PYG{l+s+sd}{    Args:}
\PYG{l+s+sd}{        image is a 80x80 pixel image that represents our reconstructed image}
\PYG{l+s+sd}{        p is the kind of norm to be used}
\PYG{l+s+sd}{        tsv is the flag for total squared variation}
\PYG{l+s+sd}{    Returns:}
\PYG{l+s+sd}{        the regularizer}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{if} \PYG{n}{tsv} \PYG{o+ow}{and} \PYG{n}{p} \PYG{o}{==} \PYG{k+kc}{None}\PYG{p}{:}
        \PYG{k}{raise} \PYG{n+ne}{Exception}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{p value not set}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{reg} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{k}{if} \PYG{n}{tsv}\PYG{p}{:}
        \PYG{n}{image\PYGZus{}lshift} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{subok}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
        \PYG{n}{image\PYGZus{}lshift} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{roll}\PYG{p}{(}\PYG{n}{image\PYGZus{}lshift}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
        \PYG{n}{image\PYGZus{}lshift}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{image\PYGZus{}lshift}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]} 
        \PYG{n}{image\PYGZus{}upshift} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{subok}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
        \PYG{n}{image\PYGZus{}upshift} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{roll}\PYG{p}{(}\PYG{n}{image\PYGZus{}upshift}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{n}{image\PYGZus{}upshift}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{image\PYGZus{}upshift}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]} 

        \PYG{n}{term\PYGZus{}1} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{power}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{absolute}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{subtract}\PYG{p}{(}\PYG{n}{image\PYGZus{}lshift}\PYG{p}{,} \PYG{n}{image}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}\PYG{n}{p}\PYG{p}{)}
        \PYG{n}{term\PYGZus{}2} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{power}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{absolute}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{subtract}\PYG{p}{(}\PYG{n}{image\PYGZus{}upshift}\PYG{p}{,} \PYG{n}{image}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}\PYG{n}{p}\PYG{p}{)}
        \PYG{n}{reg} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{term\PYGZus{}1}\PYG{p}{,}\PYG{n}{term\PYGZus{}2}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{return} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{n}{reg}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Here we test the calc\_regulaizer function using an empty image, a monotone image, and a noisy image.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{empty\PYGZus{}image} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{80}\PYG{p}{,}\PYG{l+m+mi}{80}\PYG{p}{)}\PYG{p}{)} 
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{empty\PYGZus{}image}\PYG{p}{,} \PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(\PYGZhy{}0.5, 79.5, 79.5, \PYGZhy{}0.5)
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{50044725cf3b7bb9aba8413280e2b5fac297b8a84f56bbf478d426329bef7e14}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{noisy\PYGZus{}image} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{l+m+mi}{80}\PYG{p}{,}\PYG{l+m+mi}{80}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{noisy\PYGZus{}image}\PYG{p}{,} \PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(\PYGZhy{}0.5, 79.5, 79.5, \PYGZhy{}0.5)
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{d7e93ef4f24038693672f381aeead34e7b1d99d3019776838aee5c0fd3c055b0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{monotone\PYGZus{}image} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{full}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{80}\PYG{p}{,}\PYG{l+m+mi}{80}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{monotone\PYGZus{}image}\PYG{p}{,} \PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(\PYGZhy{}0.5, 79.5, 79.5, \PYGZhy{}0.5)
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{6be4452fe7135bd154aa8e9b3b8b2f5a0a719dc140f6f685c13ea78a004b870f}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Empty:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{calc\PYGZus{}regularizer}\PYG{p}{(}\PYG{n}{empty\PYGZus{}image}\PYG{p}{,}\PYG{k+kc}{True}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Noisy:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{calc\PYGZus{}regularizer}\PYG{p}{(}\PYG{n}{noisy\PYGZus{}image}\PYG{p}{,}\PYG{k+kc}{True}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Monotone:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{calc\PYGZus{}regularizer}\PYG{p}{(}\PYG{n}{monotone\PYGZus{}image}\PYG{p}{,}\PYG{k+kc}{True}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Empty: \PYGZhy{}0.0
Noisy: \PYGZhy{}2175.392787838805
Monotone: 0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Here we see that the regularizer favors smooth images over noisy/rough ones. It is important to note that both the empty image and the monotone image have a regularizer of 0. This is because we weight the images towards smoother images.

\sphinxAtStartPar
This is the gradient of the regularizer.
We calculate each point in the picture by doing \(x_{i+1,j} + x_{i-1,j} + x_{i,j+1} + x_{i,j-1} - 4x_{i,j}\) for each i,j pixels

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{gradient\PYGZus{}regularizer}\PYG{p}{(}\PYG{n}{image}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Calculates the gradient of the regularizer}
\PYG{l+s+sd}{    Args:}
\PYG{l+s+sd}{        image is a 80x80 pixel image that represents our reconstructed image}
\PYG{l+s+sd}{    Returns:}
\PYG{l+s+sd}{        the gradient of the regularizer}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{image\PYGZus{}lshift} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{subok}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
    \PYG{n}{image\PYGZus{}lshift} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{roll}\PYG{p}{(}\PYG{n}{image\PYGZus{}lshift}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{n}{image\PYGZus{}lshift}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{image\PYGZus{}lshift}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]} 
    \PYG{n}{image\PYGZus{}upshift} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{subok}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
    \PYG{n}{image\PYGZus{}upshift} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{roll}\PYG{p}{(}\PYG{n}{image\PYGZus{}upshift}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n}{image\PYGZus{}upshift}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{image\PYGZus{}upshift}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]} 
    \PYG{n}{image\PYGZus{}rshift} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{subok}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
    \PYG{n}{image\PYGZus{}rshift} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{roll}\PYG{p}{(}\PYG{n}{image\PYGZus{}rshift}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{n}{image\PYGZus{}rshift}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{image\PYGZus{}rshift}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]} 
    \PYG{n}{image\PYGZus{}dshift} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{subok}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
    \PYG{n}{image\PYGZus{}dshift} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{roll}\PYG{p}{(}\PYG{n}{image\PYGZus{}dshift}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n}{image\PYGZus{}dshift}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{image\PYGZus{}lshift}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} 
    \PYG{n}{g\PYGZus{}reg} \PYG{o}{=} \PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{image} \PYG{o}{\PYGZhy{}} \PYG{n}{image\PYGZus{}lshift} \PYG{o}{\PYGZhy{}} \PYG{n}{image\PYGZus{}upshift} \PYG{o}{\PYGZhy{}} \PYG{n}{image\PYGZus{}rshift} \PYG{o}{\PYGZhy{}} \PYG{n}{image\PYGZus{}dshift}
    \PYG{k}{return} \PYG{n}{g\PYGZus{}reg}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Empty:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{gradient\PYGZus{}regularizer}\PYG{p}{(}\PYG{n}{empty\PYGZus{}image}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Noisy:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{gradient\PYGZus{}regularizer}\PYG{p}{(}\PYG{n}{noisy\PYGZus{}image}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Monotone:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{gradient\PYGZus{}regularizer}\PYG{p}{(}\PYG{n}{monotone\PYGZus{}image}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Empty:
 [[0. 0. 0. ... 0. 0. 0.]
 [0. 0. 0. ... 0. 0. 0.]
 [0. 0. 0. ... 0. 0. 0.]
 ...
 [0. 0. 0. ... 0. 0. 0.]
 [0. 0. 0. ... 0. 0. 0.]
 [0. 0. 0. ... 0. 0. 0.]]
Noisy:
 [[ 0.27110122 \PYGZhy{}0.26792028  0.24373484 ... \PYGZhy{}1.78212619 \PYGZhy{}0.25798071
  \PYGZhy{}1.75820855]
 [\PYGZhy{}0.05188315  0.74498931 \PYGZhy{}1.19863679 ...  2.11052592 \PYGZhy{}0.3928655
   1.5844631 ]
 [\PYGZhy{}0.83281295  1.32525577 \PYGZhy{}0.34310046 ...  1.91057963 \PYGZhy{}0.75566079
  \PYGZhy{}1.09022339]
 ...
 [\PYGZhy{}1.7355526   1.9401696  \PYGZhy{}1.88848139 ... \PYGZhy{}0.33351843 \PYGZhy{}0.75294465
  \PYGZhy{}0.99623846]
 [ 1.09733057 \PYGZhy{}0.95732659 \PYGZhy{}0.28356497 ... \PYGZhy{}1.43437622  2.56158941
  \PYGZhy{}1.81351   ]
 [ 0.35675887 \PYGZhy{}0.62055941  0.58023011 ...  1.47917241 \PYGZhy{}1.91481278
   1.58313622]]
Monotone:
 [[0 0 0 ... 0 0 0]
 [0 0 0 ... 0 0 0]
 [0 0 0 ... 0 0 0]
 ...
 [0 0 0 ... 0 0 0]
 [0 0 0 ... 0 0 0]
 [0 0 0 ... 0 0 0]]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\chapter{Loss}
\label{\detokenize{loss:loss}}\label{\detokenize{loss::doc}}
\sphinxAtStartPar
The Loss function is trying to compare the data with the image and see if they agree with each other.

\sphinxAtStartPar
Let \(I(x,y)\) be the image and we transform it into \(\hat{I} (x,y)\) by using fourier transfroms described in the the interpolate section of the previous notebook.

\sphinxAtStartPar
Next we compare each interpolated point with its data term counterpart and get the equation for loss to be:
\begin{equation*}
\begin{split}J = \sum_{i}\frac{|\hat{I}(u_i,v_i) - D_i|^2}{\sigma_i^2}\end{split}
\end{equation*}
\sphinxAtStartPar
\(\sigma_i, u_i, v_i, D_i\) are all related to the \(i^{th}\) data point.

\sphinxAtStartPar
Finally, we add the regularizer to the loss using the method in the previous notebook.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}}\PYG{k}{run} ./utility.ipynb
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Data Term calculation}
\label{\detokenize{loss:data-term-calculation}}
\sphinxAtStartPar
We have above that \(\hat{I}\) is in the Fourier Domain. In order to compute the data term, we calculate the term as \(D = \text{Amp} * e^{i*\text{phase}}\).

\sphinxAtStartPar
It is important to note that the phase in Z is in radians, not degrees

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{loss}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{:} \PYG{n+nb}{list}\PYG{p}{[}\PYG{n}{data}\PYG{p}{]}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{p} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{reg\PYGZus{}weight} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{FOV} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{o}{*}\PYG{n}{u}\PYG{o}{.}\PYG{n}{uas}\PYG{o}{.}\PYG{n}{to}\PYG{p}{(}\PYG{n}{u}\PYG{o}{.}\PYG{n}{rad}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    calculates the loss of an image compared to the data given}
\PYG{l+s+sd}{    Args:}
\PYG{l+s+sd}{        image is a 80x80 pixel image that represents our reconstructed image}
\PYG{l+s+sd}{        coords is a list of u,v coordinates that we obtained from our data}
\PYG{l+s+sd}{        p is the kind of norm to be used}
\PYG{l+s+sd}{        reg\PYGZus{}weight is the regularizer weight}
\PYG{l+s+sd}{        FOV is the Field of view from the telescopes. For the EHT data, our FOV is 100 micro ascs.}
\PYG{l+s+sd}{    Returns:}
\PYG{l+s+sd}{        a loss value}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{error\PYGZus{}sum} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{n}{vis\PYGZus{}images} \PYG{o}{=} \PYG{n}{interpolate}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{FOV}\PYG{p}{)}
    
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{vis\PYGZus{}data} \PYG{o}{=} \PYG{n}{data\PYGZus{}list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{amp} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{n}{j} \PYG{o}{*} \PYG{n}{math}\PYG{o}{.}\PYG{n}{radians}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{phase}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{vis\PYGZus{}image} \PYG{o}{=} \PYG{n}{vis\PYGZus{}images}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
        \PYG{n}{error} \PYG{o}{=} \PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{vis\PYGZus{}image}\PYG{o}{\PYGZhy{}}\PYG{n}{vis\PYGZus{}data}\PYG{p}{)} \PYG{o}{/} \PYG{n}{data\PYGZus{}list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{sigma}\PYG{p}{)} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}
        \PYG{n}{error\PYGZus{}sum} \PYG{o}{+}\PYG{o}{=} \PYG{n}{error}
    
    \PYG{k}{return} \PYG{n}{error\PYGZus{}sum} \PYG{o}{+} \PYG{n}{reg\PYGZus{}weight} \PYG{o}{*} \PYG{n}{calc\PYGZus{}regularizer}\PYG{p}{(}\PYG{n}{image}\PYG{o}{=}\PYG{n}{image}\PYG{p}{,} \PYG{n}{tsv}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{p}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Furthermore into the data}
\label{\detokenize{loss:furthermore-into-the-data}}
\sphinxAtStartPar
What we are doing here is a simplified version of the loss function. In reality, the loss is more complicated due to other factors.

\sphinxAtStartPar
Because of the method of combining signal data from many telescopes, we get errors that may throw off the data terms.

\sphinxAtStartPar
How would we change our loss function?


\subsection{Method One: Gain}
\label{\detokenize{loss:method-one-gain}}
\sphinxAtStartPar
We add a new function called the Gain which represents the telescoping errors. It is a smooth function in time that has a phase and amplitude. We multiply it with the data term to result in:
\begin{equation*}
\begin{split}J = \sum_{i}\frac{|\hat{I}(u_i,v_i) - G_i D_i|^2}{\sigma_i^2}\end{split}
\end{equation*}
\sphinxAtStartPar
\(\sigma_i, u_i, v_i, D_i, G_i\) are all related to the \(i^{th}\) data point.

\sphinxAtStartPar
This loss function becomes the one we are trying to minimize.


\subsection{Method Two: Closure Phase}
\label{\detokenize{loss:method-two-closure-phase}}
\sphinxAtStartPar
The other way is to take into the account the Closure Phase.

\sphinxAtStartPar
We construct these terms by summing over the data and using triples of telescopes:
\begin{equation*}
\begin{split} \sum_{i,j,k} \frac{|\phi_{i,j} + \phi_{j,k} + \phi_{k,i} - \phi_{\hat{I}}|^2}{\sigma^2} \text{ where }i \neq j \neq k\end{split}
\end{equation*}
\sphinxAtStartPar
\(\phi_{i,j} + \phi_{j,k} + \phi_{k,i}\) is called the Closure Phase \(CP\) which is independent of the telescope error and is taken from the data. \(\phi_{\hat{I}}\) is a Closure Phase computed from the image. Closure Phase as defined here is independent from complex visibilities from the telescopes. This is because complex visibilities affect Amplitude (which doesn’t appear here) and phase. The complex visibilites affect phase in an additive fashion and in this triple combination, the phase’s complex visibilities cancel.

\sphinxAtStartPar
In practice, these are the two major methods in order to fit the image to the data.

\sphinxAtStartPar
For the purposes of this notebook however we will be simplifying the problem and setting these visibilities to one.


\section{Testing the function}
\label{\detokenize{loss:testing-the-function}}
\sphinxAtStartPar
Below we have a image that was generated for testing purposes. Sometimes we want to shift the image in someway so that the loss function can be optimized further. In EHT, they have tested with many variations and come up with the loss being the best with the ring centered in the middle. We will test this claim below.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sample} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{loadtxt}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{images/data.csv}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{delimiter}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(\PYGZhy{}0.5, 79.5, 79.5, \PYGZhy{}0.5)
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{09be506f97fad65651b949fb269182d142b16cb4c9f2ecebe9fd3a98f4952fd3}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Here we generate a coords and data\_list list by sampling data from the ring (not the noise around the ring).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{do\PYGZus{}sample}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Collects n samples from a sample image}
\PYG{l+s+sd}{    Args:}
\PYG{l+s+sd}{        n is the number of samples as an integer}
\PYG{l+s+sd}{    Returns:}
\PYG{l+s+sd}{        a list of coordinates in u,v space}
\PYG{l+s+sd}{        a list of data objects}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{coords} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{data\PYGZus{}list} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{ft\PYGZus{}image} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fftshift}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fft2}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{coords}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{10}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{10}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{data\PYGZus{}list}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{data}\PYG{p}{(}\PYG{n}{coords}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ft\PYGZus{}image}\PYG{p}{[}\PYG{n}{coords}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{+}\PYG{l+m+mi}{40}\PYG{p}{]}\PYG{p}{[}\PYG{n}{coords}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{l+m+mi}{40}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{coords}\PYG{p}{,} \PYG{n}{data\PYGZus{}list} \PYG{o}{=} \PYG{n}{do\PYGZus{}sample}\PYG{p}{(}\PYG{l+m+mi}{25}\PYG{p}{)}
\PYG{n}{data\PYGZus{}list}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[[u: \PYGZhy{}2, v: \PYGZhy{}3],
 [u: 1, v: 0],
 [u: 4, v: \PYGZhy{}2],
 [u: 4, v: \PYGZhy{}2],
 [u: \PYGZhy{}4, v: 2],
 [u: 4, v: 3],
 [u: 0, v: 1],
 [u: 4, v: \PYGZhy{}3],
 [u: 4, v: 0],
 [u: \PYGZhy{}4, v: 4],
 [u: 1, v: \PYGZhy{}3],
 [u: \PYGZhy{}3, v: \PYGZhy{}2],
 [u: 3, v: \PYGZhy{}4],
 [u: 1, v: \PYGZhy{}3],
 [u: \PYGZhy{}4, v: \PYGZhy{}1],
 [u: 1, v: \PYGZhy{}2],
 [u: 2, v: 0],
 [u: 4, v: 0],
 [u: 2, v: \PYGZhy{}1],
 [u: \PYGZhy{}3, v: \PYGZhy{}2],
 [u: 2, v: 1],
 [u: 2, v: \PYGZhy{}4],
 [u: 3, v: 1],
 [u: \PYGZhy{}2, v: 1],
 [u: 4, v: 4]]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
It is important to note here that the data points in data\_list is complex. Since we sampled from the fourier transform, we have no need to calcuate the data term like we do in the loss function above. Below is a altered version of the loss function above.

\sphinxAtStartPar
Finally, below we calcuate the loss of the sample image we started with and then shift the image in all directions. Then we plot the array of losses that we obtained.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{calculate\PYGZus{}losses}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Calculates the losses of the image by shifting it around }
\PYG{l+s+sd}{    Args:}
\PYG{l+s+sd}{        None}
\PYG{l+s+sd}{    Returns:}
\PYG{l+s+sd}{        an array of losses where the index is how much the image is shifted starting with \PYGZhy{}40 to 40}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{loss\PYGZus{}arr} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{)}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{image\PYGZus{}1} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{roll}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{,} \PYG{n}{i}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Right shifts}
        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{image\PYGZus{}2} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{roll}\PYG{p}{(}\PYG{n}{image\PYGZus{}1}\PYG{p}{,} \PYG{n}{j}\PYG{p}{,} \PYG{n}{axis} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Up shifts}
            \PYG{n}{loss\PYGZus{}arr}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{loss}\PYG{p}{(}\PYG{n}{image\PYGZus{}2}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{reg\PYGZus{}weight}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{FOV}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
            
    \PYG{n}{loss\PYGZus{}arr1} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{roll}\PYG{p}{(}\PYG{n}{loss\PYGZus{}arr}\PYG{p}{,} \PYG{l+m+mi}{40}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{n}{loss\PYGZus{}arr2} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{roll}\PYG{p}{(}\PYG{n}{loss\PYGZus{}arr1}\PYG{p}{,} \PYG{l+m+mi}{40}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}

    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{loss\PYGZus{}arr2}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{loss\PYGZus{}arr}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{loss\PYGZus{}arr} \PYG{o}{=} \PYG{n}{calculate\PYGZus{}losses}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{4a77565af8594be5c959a8880403a4ec5ed7ef30e4bd75806bff086619b2d4cf}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
The dark spots in this picture are low points while the yellow spots are high points. Here we see that there are a few spots where the image produces low loss. If ran again, we will get differing behaviors

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{coords}\PYG{p}{,} \PYG{n}{data\PYGZus{}list} \PYG{o}{=} \PYG{n}{do\PYGZus{}sample}\PYG{p}{(}\PYG{l+m+mi}{25}\PYG{p}{)}
\PYG{n}{loss\PYGZus{}arr} \PYG{o}{=} \PYG{n}{calculate\PYGZus{}losses}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{d4430ec1007d8d8da4dae2be5e320b38fb394ee3760503945796d30bdaebd123}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{coords}\PYG{p}{,} \PYG{n}{data\PYGZus{}list} \PYG{o}{=} \PYG{n}{do\PYGZus{}sample}\PYG{p}{(}\PYG{l+m+mi}{25}\PYG{p}{)}
\PYG{n}{loss\PYGZus{}arr} \PYG{o}{=} \PYG{n}{calculate\PYGZus{}losses}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{e28173b92553f34ae26fc0ba521a496da45448c94d6e5b84dc7582164c48cf85}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{coords}\PYG{p}{,} \PYG{n}{data\PYGZus{}list} \PYG{o}{=} \PYG{n}{do\PYGZus{}sample}\PYG{p}{(}\PYG{l+m+mi}{25}\PYG{p}{)}
\PYG{n}{loss\PYGZus{}arr} \PYG{o}{=} \PYG{n}{calculate\PYGZus{}losses}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{3892057d86f1d8515e690c03cb5af3191db489d2034b3304cbec845e9338be70}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
In all four of these trials (and other reruns that we test), we generally see dark spots in the centers suggesting that the best area to put the ring is centered in the middle of the image

\sphinxstepscope


\chapter{Gradient Calculations: Finite Differences}
\label{\detokenize{finite_gradient:gradient-calculations-finite-differences}}\label{\detokenize{finite_gradient::doc}}
\sphinxAtStartPar
We have two different methods of computing gradients and in this notebook we will explore the first one.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}}\PYG{k}{run} ./utility.ipynb
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Gradient’s Background}
\label{\detokenize{finite_gradient:gradient-s-background}}
\sphinxAtStartPar
A gradient is vector where the direction is towards greatest rate of change when looking at a scalar function and the magnitude is the greatest rate of change. In our model, the gradient will be positive or negative depending on if a pixel’s value must in increased or decreased. The gradient is vector where each pixel has its own component in the gradient.

\sphinxAtStartPar
Here’s an intuitive way of looking at gradients: Image you are standing in Tucson at Alvernon and Grant and we are interested in the function f that tells you your elevation. The gradient of f will always tell you which direction you should travel in in order to rise in elevation the quickest.

\sphinxAtStartPar
If the function is smooth then we can use gradients to find local maximums and minimums by simply following the gradient until either the gradient is 0 or we never finish (in the event of infinity end behaviors).

\sphinxAtStartPar
Why are gradient’s important? In the real world, gradients are used in many fields like physics, robotics, and optimizations. We use it all the time in order to quanify the net rate of change in multi\sphinxhyphen{}variable functions!


\section{Method one: Finite Differences Methods}
\label{\detokenize{finite_gradient:method-one-finite-differences-methods}}
\sphinxAtStartPar
The Finite Differences Method are a numerical analysis technique for solving differential equations by approximating derivatves using finite differences. Using these finite differences we can approximate a gradient of a function which we will denote as \(\nabla f\).

\sphinxAtStartPar
So what is Finite Differences exactly? It is a mathematical expression of the form \(f(x+b)-f(x+a)\).

\sphinxAtStartPar
There are three basic types that are commonly considered for this method: Forward, Backward, and Central.

\sphinxAtStartPar
Forward differences is calcuated by \(\nabla f = \frac{f(x+h)-f(x)}{h}\)

\sphinxAtStartPar
Backward differences is calcuated by \(\nabla f = \frac{f(x) - f(x-h)}{h}\)

\sphinxAtStartPar
Central differences is calcuated by \(\nabla f = \frac{f(x+\frac{h}{2})-f(x-\frac{h}{2})}{h}\)


\subsection{The Function Implemented}
\label{\detokenize{finite_gradient:the-function-implemented}}
\sphinxAtStartPar
Below we have all three methods implemented controlled by a mode flag.

\sphinxAtStartPar
For Gradient Descent, we consider \(f\) to be our loss function and h to be a minute difference from a pixel’s value. We iterate over every pixel and calculate the loss needed for equation used (\(f(x+h)\), \(f(x-h)\), or \(f(x+\frac{h}{2})-f(x-\frac{h}{2})\)). This gives us the gradient for each pixel.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{gradient\PYGZus{}finite\PYGZus{}differences}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{:} \PYG{n+nb}{list}\PYG{p}{[}\PYG{n}{data}\PYG{p}{]}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{image}\PYG{p}{,} \PYG{n}{mode} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{FOV} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{o}{*}\PYG{n}{u}\PYG{o}{.}\PYG{n}{uas}\PYG{o}{.}\PYG{n}{to}\PYG{p}{(}\PYG{n}{u}\PYG{o}{.}\PYG{n}{rad}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Calculates a gradient based on finite differences}
\PYG{l+s+sd}{    Args:}
\PYG{l+s+sd}{        data\PYGZus{}list is a list of data objects}
\PYG{l+s+sd}{        coords is a list of u,v coordinates that we obtained from our data}
\PYG{l+s+sd}{        image is a 80x80 pixel image that represents our reconstructed image}
\PYG{l+s+sd}{        mode is the type of difference used: 0 For central, \PYGZhy{}1 for backward, 1 for forward}
\PYG{l+s+sd}{        FOV is the Field of view from the telescopes. For the EHT data, our FOV is 100 micro ascs.}
\PYG{l+s+sd}{    Returns:}
\PYG{l+s+sd}{        the gradient of the loss function}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{image\PYGZus{}copy} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{subok}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
    \PYG{n}{upper\PYGZus{}diff}\PYG{p}{:} \PYG{n+nb}{float}
    \PYG{n}{lower\PYGZus{}diff}\PYG{p}{:} \PYG{n+nb}{float}
    \PYG{n}{h}\PYG{p}{:} \PYG{n+nb}{float}
    \PYG{n}{gradient\PYGZus{}arr} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{p}{,}\PYG{n}{dtype}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{complex\PYGZus{}}\PYG{p}{)}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{mode} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} Central difference}
        \PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{for} \PYG{n}{col} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{image}\PYG{p}{[}\PYG{n}{row}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{image\PYGZus{}copy}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}6} \PYG{o}{/} \PYG{l+m+mi}{2}
                \PYG{n}{upper\PYGZus{}diff} \PYG{o}{=} \PYG{n}{loss}\PYG{p}{(}\PYG{n}{image\PYGZus{}copy}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{FOV}\PYG{o}{=}\PYG{n}{FOV}\PYG{p}{)}
                \PYG{n}{image\PYGZus{}copy}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}6}
                \PYG{n}{lower\PYGZus{}diff} \PYG{o}{=} \PYG{n}{loss}\PYG{p}{(}\PYG{n}{image\PYGZus{}copy}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{FOV}\PYG{o}{=}\PYG{n}{FOV}\PYG{p}{)}
                \PYG{n}{image\PYGZus{}copy}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]} \PYG{o}{=} \PYG{n}{image}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} Reset that pixel to original value}
                \PYG{n}{gradient\PYGZus{}arr}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{n}{upper\PYGZus{}diff} \PYG{o}{\PYGZhy{}} \PYG{n}{lower\PYGZus{}diff}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mf}{1e\PYGZhy{}6}
    \PYG{k}{elif} \PYG{p}{(}\PYG{n}{mode} \PYG{o}{==} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} Backward difference}
        \PYG{n}{upper\PYGZus{}diff} \PYG{o}{=} \PYG{n}{loss}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{FOV}\PYG{o}{=}\PYG{n}{FOV}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{for} \PYG{n}{col} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{image}\PYG{p}{[}\PYG{n}{row}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{image\PYGZus{}copy}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}8}
                \PYG{n}{lower\PYGZus{}diff} \PYG{o}{=} \PYG{n}{loss}\PYG{p}{(}\PYG{n}{image\PYGZus{}copy}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{FOV}\PYG{o}{=}\PYG{n}{FOV}\PYG{p}{)}
                \PYG{n}{gradient\PYGZus{}arr}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{n}{upper\PYGZus{}diff} \PYG{o}{\PYGZhy{}} \PYG{n}{lower\PYGZus{}diff}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mf}{1e\PYGZhy{}8}
                \PYG{n}{image\PYGZus{}copy}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]} \PYG{o}{=} \PYG{n}{image}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]}
    \PYG{k}{elif} \PYG{p}{(}\PYG{n}{mode} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{:} \PYG{c+c1}{\PYGZsh{} Forward difference is default}
        \PYG{n}{lower\PYGZus{}diff} \PYG{o}{=} \PYG{n}{loss}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{FOV}\PYG{o}{=}\PYG{n}{FOV}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{for} \PYG{n}{col} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{image}\PYG{p}{[}\PYG{n}{row}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{image\PYGZus{}copy}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}8} 
                \PYG{n}{upper\PYGZus{}diff} \PYG{o}{=} \PYG{n}{loss}\PYG{p}{(}\PYG{n}{image\PYGZus{}copy}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{FOV}\PYG{o}{=}\PYG{n}{FOV}\PYG{p}{)}
                \PYG{n}{gradient\PYGZus{}arr}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{n}{upper\PYGZus{}diff} \PYG{o}{\PYGZhy{}} \PYG{n}{lower\PYGZus{}diff}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mf}{1e\PYGZhy{}8}
                \PYG{n}{image\PYGZus{}copy}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]} \PYG{o}{=} \PYG{n}{image}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{k}{raise} \PYG{n+ne}{ValueError}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Incorrect mode for finite differences}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{gradient\PYGZus{}arr}\PYG{o}{.}\PYG{n}{real}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Final Note: Why do we use 1e\sphinxhyphen{}6 and 1e\sphinxhyphen{}8.

\sphinxAtStartPar
When we want to estimate our loss function using the method below.

\sphinxAtStartPar
Consider the loss function f and we want to estimate it at point x as a finite difference. Additionally, let g be the numerical computation of f. Then we consider the analysis below
\begin{equation*}
\begin{split}f'_h = max_{\Delta x} \frac{|\frac{g(x+\delta x + h) - g(x+\delta x)}{h} -f'(x)|}{|f'(x)|}|\frac{x}{\Delta x}|\end{split}
\end{equation*}\begin{equation*}
\begin{split}\sim \frac{|g(x+h) - g(x) -f'(x)h|}{\epsilon_{machine}h|f'(x)|}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\sim\frac{\epsilon_{machine}f +(\frac{fh^2}{L^2})}{\frac{\epsilon_{machine}hf}{L}}\end{split}
\end{equation*}\begin{equation*}
\begin{split} = \frac{L}{h} + \frac{h}{\epsilon_{machine}L}\end{split}
\end{equation*}
\sphinxAtStartPar
Here, L is a characteristic scale of x and \(\epsilon_{machine}\) is the error of the machine. By minimizing \(f'_h\) with respect to h, we find that \(h \sim \sqrt{\epsilon_{machine}}L\). With \(L\sim 1\), \(h \sim \sqrt{\epsilon_{machine}}\).

\sphinxAtStartPar
Why don’t we use other values of h?

\sphinxAtStartPar
We have to balance between two types of errors: The first being the error due to numerical errors within g. As h becomes two small, the error becomes bigger. The other error is from the higher order derivatives of the function f. As h grows larger, the higher order derivatives start to dominate the approximation.

\sphinxAtStartPar
How does this connect to 1e\sphinxhyphen{}6 and 1e\sphinxhyphen{}8?

\sphinxAtStartPar
Floats in Python use IEEE Double Precision format which gives allows for it to compare up to \(10^{-16}\) precision between two values. In forward and backward differences, the \(h\) value uses the square root of \(10^{-16}\) which is \(10^{-8}\). In central differences, the \(h\) value uses a cubic root which means it uses roughly \(10^{-6}\)


\subsection{Demo Walkthrough}
\label{\detokenize{finite_gradient:demo-walkthrough}}
\sphinxAtStartPar
Start with an empty or blank image

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{emp} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{80}\PYG{p}{,}\PYG{l+m+mi}{80}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{emp}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(\PYGZhy{}0.5, 79.5, 79.5, \PYGZhy{}0.5)
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{50044725cf3b7bb9aba8413280e2b5fac297b8a84f56bbf478d426329bef7e14}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Next we get the sample data points from our synthetic data. Afterwards we will run our gradient code.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sample} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{loadtxt}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{images/data.csv}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{delimiter}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{coords}\PYG{p}{,} \PYG{n}{data\PYGZus{}list} \PYG{o}{=} \PYG{n}{do\PYGZus{}sample}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{gradient\PYGZus{}finite\PYGZus{}differences}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{emp}\PYG{p}{,} \PYG{n}{FOV} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(\PYGZhy{}0.5, 79.5, 79.5, \PYGZhy{}0.5)
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{a83f03102c1b5343ddd01aa216c66aca1784f49105447f12fe1b1476c3a5b0f2}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Above is the image representation of the gradient, darker areas represent smaller gradients and lighter areas represent bigger gradients.

\sphinxAtStartPar
It is specifically a gradient when we start our “image” as an empty or blank image. The gradient above shows which pixels are different than what we would expect given a data set (whether some should be brighter, darker or stay the same).


\section{Gradient Descent}
\label{\detokenize{finite_gradient:gradient-descent}}
\sphinxAtStartPar
Now that we have computed a gradient, we can now start doing gradient descent. Gradient Descent is an optimization algorithm for finding local minimum within a differentiable function. We can use this to find values of parameters that minimize some sort of cost function. Here, the parameters as simply each pixel in our image, and the cost functions that we are trying to minimize is the loss function.

\sphinxAtStartPar
Heres how it works. We first calcualte the loss at the current position. The algorithm then iteratively calculates the next image by using the gradient at the current position. We scale the gradient so that we can obtain a loss less than the current loss and then subtract the scaled gradient from the image. This is called a single step. We subtract the gradient because we are looking to minimise the function rather than maximizing it.

\sphinxAtStartPar
We take a bunch of these steps until we hit some stopping condition (here it is \sphinxcode{\sphinxupquote{np.min(np.abs(grad)) <= 0.0000001}}).

\sphinxAtStartPar
The choosing of step size (the scaling of the gradient) is important because if not chosen properly, it will lead to this pattern called zig\sphinxhyphen{}zagging. This would then cause the program to reach the minimum slower than it would have by going on a straight path.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{gradient\PYGZus{}descent}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{coeffs} \PYG{o}{=} \PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{FOV} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{o}{*}\PYG{n}{u}\PYG{o}{.}\PYG{n}{uas}\PYG{o}{.}\PYG{n}{to}\PYG{p}{(}\PYG{n}{u}\PYG{o}{.}\PYG{n}{rad}\PYG{p}{)}\PYG{p}{,} \PYG{n}{stopper} \PYG{o}{=} \PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{dirty} \PYG{o}{=} \PYG{k+kc}{False}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Performs gradient descent to reconstruct the image}
\PYG{l+s+sd}{    Args:}
\PYG{l+s+sd}{        image is a 80x80 pixel image that represents our reconstructed image}
\PYG{l+s+sd}{        data\PYGZus{}list is a list of data objects}
\PYG{l+s+sd}{        coords is a list of u,v coordinates that we obtained from our data}
\PYG{l+s+sd}{        coeffs is the precomputed coefficients}
\PYG{l+s+sd}{        FOV is the Field of view from the telescopes. For the EHT data, our FOV is 100 micro ascs.}
\PYG{l+s+sd}{        stopper allows the descent to stop at 20 iterations}
\PYG{l+s+sd}{        dirty changes the gradient mode to dirty kernel}
\PYG{l+s+sd}{    Returns:}
\PYG{l+s+sd}{        the reconstructed image}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{image\PYGZus{}copy} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{subok}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Uses copy of the image due to lists being mutable in python}
    \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{n}{grad} \PYG{o}{=} \PYG{k+kc}{None}
    \PYG{n}{losses\PYGZus{}arr} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{c+c1}{\PYGZsh{} Can also use max here, min just makes it finish quicker}
    \PYG{k}{while} \PYG{n}{grad} \PYG{o+ow}{is} \PYG{k+kc}{None} \PYG{o+ow}{or} \PYG{n}{np}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{grad}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{0.00001}\PYG{p}{:}
        \PYG{n}{t} \PYG{o}{=} \PYG{l+m+mi}{10000000} \PYG{c+c1}{\PYGZsh{} Initial Step size which resets each iteration}
        \PYG{n}{prev\PYGZus{}loss} \PYG{o}{=} \PYG{n}{loss}\PYG{p}{(}\PYG{n}{image\PYGZus{}copy}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{FOV}\PYG{o}{=}\PYG{n}{FOV}\PYG{p}{)}

        \PYG{k}{if} \PYG{n}{dirty}\PYG{p}{:}
            \PYG{n}{grad} \PYG{o}{=} \PYG{n}{dirty\PYGZus{}gradient}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{coeffs}\PYG{p}{,} \PYG{n}{image\PYGZus{}copy}\PYG{p}{)}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{n}{grad} \PYG{o}{=} \PYG{n}{gradient\PYGZus{}finite\PYGZus{}differences}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{image\PYGZus{}copy}\PYG{p}{,} \PYG{n}{FOV}\PYG{o}{=}\PYG{n}{FOV}\PYG{p}{)}

        \PYG{n}{new\PYGZus{}image} \PYG{o}{=} \PYG{n}{image\PYGZus{}copy} \PYG{o}{\PYGZhy{}} \PYG{n}{t} \PYG{o}{*} \PYG{n}{grad}\PYG{o}{.}\PYG{n}{real}
        \PYG{n}{new\PYGZus{}loss} \PYG{o}{=} \PYG{n}{loss}\PYG{p}{(}\PYG{n}{new\PYGZus{}image}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{FOV}\PYG{o}{=}\PYG{n}{FOV}\PYG{p}{)}
        
        \PYG{k}{while} \PYG{n}{new\PYGZus{}loss} \PYG{o}{\PYGZgt{}} \PYG{n}{prev\PYGZus{}loss}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} Only run when new\PYGZus{}loss \PYGZgt{} prev\PYGZus{}loss}
            \PYG{n}{new\PYGZus{}image} \PYG{o}{=} \PYG{n}{image\PYGZus{}copy} \PYG{o}{\PYGZhy{}} \PYG{n}{t} \PYG{o}{*} \PYG{n}{grad}\PYG{o}{.}\PYG{n}{real}
            \PYG{n}{new\PYGZus{}loss} \PYG{o}{=} \PYG{n}{loss}\PYG{p}{(}\PYG{n}{new\PYGZus{}image}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{FOV}\PYG{o}{=}\PYG{n}{FOV}\PYG{p}{)}
            \PYG{n}{t} \PYG{o}{/}\PYG{o}{=} \PYG{l+m+mi}{2}

        \PYG{n}{image\PYGZus{}copy} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{t} \PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{grad}\PYG{o}{.}\PYG{n}{real} \PYG{c+c1}{\PYGZsh{} Multiply by 2 to undo last divide in the while loop}
        \PYG{n}{i} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
        \PYG{k}{if} \PYG{n}{stopper} \PYG{o}{!=} \PYG{k+kc}{None}\PYG{p}{:}
            \PYG{k}{if} \PYG{n}{i} \PYG{o}{==} \PYG{n}{stopper}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} Hard stop here for notebook purposes}
                \PYG{k}{break}
        \PYG{n}{losses\PYGZus{}arr}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{n}{new\PYGZus{}loss}\PYG{p}{)}\PYG{p}{)}

    \PYG{n}{time\PYGZus{}step} \PYG{o}{=} \PYG{p}{[}\PYG{n}{i} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{losses\PYGZus{}arr}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{time\PYGZus{}step}\PYG{p}{,} \PYG{n}{losses\PYGZus{}arr}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ln(loss) vs time}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{loss}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{time t}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{image\PYGZus{}copy}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Here is what the gradient descent’s output looks like after just 15 iterations. The code should be ran using

\begin{sphinxVerbatim}[commandchars=\\\{\}]
reconstructed\PYGZus{}img = gradient\PYGZus{}descent(emp, data\PYGZus{}list, coords)
\end{sphinxVerbatim}

\sphinxAtStartPar
You will notices that the loss decreases very rapidly towards zero

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{coords}\PYG{p}{,} \PYG{n}{data\PYGZus{}list} \PYG{o}{=} \PYG{n}{do\PYGZus{}sample}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}
\PYG{n}{reconstructed\PYGZus{}img} \PYG{o}{=} \PYG{n}{gradient\PYGZus{}descent}\PYG{p}{(}\PYG{n}{emp}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{FOV} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{stopper} \PYG{o}{=} \PYG{l+m+mi}{12}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
/var/folders/\PYGZus{}b/trlmhkgj5xq968yccj4vtg1c0000gn/T/ipykernel\PYGZus{}83776/4118681095.py:42: RuntimeWarning: invalid value encountered in log
  losses\PYGZus{}arr.append(np.log(new\PYGZus{}loss))
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{0b10be195aea8b1ce332477ef50134d88ccaf47da2a5ccf117ac2decd505be7d}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{reconstructed\PYGZus{}img}\PYG{p}{,} \PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{vmax}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Reconstructed Image}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Text(0.5, 1.0, \PYGZsq{}Reconstructed Image\PYGZsq{})
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{0ff37068d6288c6b14ce01930f030006eabe8f5abc548639cadfd298d7266fed}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
After another 20 iterations, you should see this:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{reconstructed\PYGZus{}img} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{loadtxt}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{images/reconstructed\PYGZus{}img\PYGZus{}prev.csv}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{delimiter}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{reconstructed\PYGZus{}img}\PYG{p}{,} \PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{vmax}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Reconstructed Image}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Text(0.5, 1.0, \PYGZsq{}Reconstructed Image\PYGZsq{})
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{9cb060127a661f09b503885d5baabee61b6b12a604a4983b6694cebfd147273f}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Here is the original image that the data was taken from

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{,} \PYG{n}{vmin}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{vmax}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{True Image}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Text(0.5, 1.0, \PYGZsq{}True Image\PYGZsq{})
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{46df12f467cddacf55c4c787ae5514a0fb1ff48ff0121687b6c80f7cb234c12d}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
As you can see here, the reconstructed image doesn’t replicate the original image directly but it will still reconstruct some of the big important features that EHT Analysis uses. Here we can see the general shape of the reconstructed image matches up with the original image


\subsection{Running gradient on Real EHT Data}
\label{\detokenize{finite_gradient:running-gradient-on-real-eht-data}}
\sphinxAtStartPar
Here is code to run this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
df = read\PYGZus{}data(\PYGZdq{}./data/SR1\PYGZus{}M87\PYGZus{}2017\PYGZus{}095\PYGZus{}hi\PYGZus{}hops\PYGZus{}netcal\PYGZus{}StokesI.csv\PYGZdq{})
coords, data\PYGZus{}list = process\PYGZus{}data(df)
x = gradient\PYGZus{}finite\PYGZus{}differences(data\PYGZus{}list, coords, emp)
\end{sphinxVerbatim}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{loadtxt}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{images/real\PYGZus{}gradient.csv}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{delimiter}\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(\PYGZhy{}0.5, 79.5, 79.5, \PYGZhy{}0.5)
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{c07baec3717009340b7e2721df3ed9454be1b90bbac6c0738559002c3bbca195}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\chapter{Gradient Calculations: “Dirtying” the Image}
\label{\detokenize{dirty_gradient:gradient-calculations-dirtying-the-image}}\label{\detokenize{dirty_gradient::doc}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}}\PYG{k}{run} ./utility.ipynb
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Method two: Dirtying the Image}
\label{\detokenize{dirty_gradient:method-two-dirtying-the-image}}
\sphinxAtStartPar
Here, we use a different method of computing gradients in order to speed up the gradient calculation process. By doing so, we should also see an increase in speed for the gradient descent.

\sphinxAtStartPar
First we start with the Gradient calculation. Consider the following loss term
\begin{equation*}
\begin{split}L_{data}(I) = \sum_a\frac{|I(u_a,v_a)-O_a|^2}{\sigma_a^2}\end{split}
\end{equation*}
\sphinxAtStartPar
Here a represents which data point, O\_a represents the data point itself, i and j are pixel coordinates, \(I_{ij}\) is the image. By doing this, we get the gradient to be:
\begin{equation*}
\begin{split}G_{ij} = \frac{\partial L_{data}}{\partial I_{ij}} = \sum_a \frac{1}{\sigma_a^2}(\frac{\partial I(u_a,v_a)}{\partial I_{ij}}(I^*(u_a,v_a)-O_a^*) + (I(u_a,v_a)-O_a)\frac{\partial I^*(u_a,v_a)}{\partial I_{ij}})\end{split}
\end{equation*}
\sphinxAtStartPar
Ideally we can compute the partial derivates as
\begin{equation*}
\begin{split}\frac{\partial I(u_a,v_a)}{\partial I_{ij}} = exp(\frac{2\pi i}{N}(iu_a+jv_a)), \frac{\partial I^*(u_a,v_a)}{\partial I_{ij}} = exp(-\frac{2\pi i}{N}(iu_a+jv_a))\end{split}
\end{equation*}
\sphinxAtStartPar
N is the size of the image in pixels

\sphinxAtStartPar
We can further define things like so:

\sphinxAtStartPar
We introduce the so\sphinxhyphen{}called “dirty” image from observations as
\begin{equation*}
\begin{split}DO_{ij} = \sum_a \frac{1}{\sigma^2_a}\frac{\partial I^*(u_a,v_a)}{\partial I_{ij}}O_a\end{split}
\end{equation*}
\sphinxAtStartPar
Here \(I^*(u_a,v_a)\) is the fourier domain of the image at an observed data point.

\sphinxAtStartPar
We also define the “dirtying” of the image I as
\begin{equation*}
\begin{split}DI_{ij} = \sum_a \frac{1}{\sigma^2_a}\frac{\partial I^*(u_a,v_a)}{\partial I_{ij}}I(u_a,v_a)\end{split}
\end{equation*}
\sphinxAtStartPar
This then gives us that
\begin{equation*}
\begin{split}G_{ij} = 2Re(DI_{ij}-DO_{ij})\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sample} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{loadtxt}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{images/data.csv}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{delimiter}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{coords}\PYG{p}{,} \PYG{n}{data\PYGZus{}list} \PYG{o}{=} \PYG{n}{do\PYGZus{}sample}\PYG{p}{(}\PYG{l+m+mi}{25}\PYG{p}{)}
\PYG{n}{emp} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{80}\PYG{p}{,}\PYG{l+m+mi}{80}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Here we preprocess and compute \(\frac{\partial I(u_a,v_a)}{\partial I_{ij}}, \frac{\partial I^*(u_a,v_a)}{\partial I_{ij}}\)

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{preprocess\PYGZus{}gradient}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{image}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Precomputed the coefficients decribed in dirty gradient}
\PYG{l+s+sd}{    Args:}
\PYG{l+s+sd}{        data\PYGZus{}list is a list of data objects}
\PYG{l+s+sd}{        coords is a list of u,v coordinates that we obtained from our data}
\PYG{l+s+sd}{        image is a 80x80 pixel image that represents our reconstructed image}
\PYG{l+s+sd}{    Returns:}
\PYG{l+s+sd}{        a 4d list of coefficients}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{r}\PYG{p}{,} \PYG{n}{c} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}
    \PYG{n}{preprocessed} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{[}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{complex\PYGZus{}}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{col} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{image}\PYG{p}{[}\PYG{n}{row}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{for} \PYG{n}{datum} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{term} \PYG{o}{=} \PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{*}\PYG{l+m+mi}{1}\PYG{n}{j}\PYG{p}{)}\PYG{o}{/}\PYG{n}{image}\PYG{o}{.}\PYG{n}{size}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n}{row}\PYG{o}{*}\PYG{n}{coords}\PYG{p}{[}\PYG{n}{datum}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{n}{col}\PYG{o}{*}\PYG{n}{coords}\PYG{p}{[}\PYG{n}{datum}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}.size for numpy array returns \PYGZsh{} of rows * \PYGZsh{} of cols}
                \PYG{n}{term\PYGZus{}1} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{term}\PYG{p}{)}
                \PYG{n}{term\PYGZus{}2} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{term}\PYG{p}{)}
                \PYG{n}{preprocessed}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{,}\PYG{n}{datum}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{term\PYGZus{}1}
                \PYG{n}{preprocessed}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{,}\PYG{n}{datum}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{term\PYGZus{}2}
    \PYG{k}{return} \PYG{n}{preprocessed}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{coeffs} \PYG{o}{=} \PYG{n}{preprocess\PYGZus{}gradient}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{emp}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Now, we can use the formula above to compute the gradient of the image directly

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{dirty\PYGZus{}gradient}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{:} \PYG{n+nb}{list}\PYG{p}{[}\PYG{n}{data}\PYG{p}{]}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{coeffs}\PYG{p}{,} \PYG{n}{image}\PYG{p}{,} \PYG{n}{FOV} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{o}{*}\PYG{n}{u}\PYG{o}{.}\PYG{n}{uas}\PYG{o}{.}\PYG{n}{to}\PYG{p}{(}\PYG{n}{u}\PYG{o}{.}\PYG{n}{rad}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Calculates a gradient based on dirting the image}
\PYG{l+s+sd}{    Args:}
\PYG{l+s+sd}{        data\PYGZus{}list is a list of data objects}
\PYG{l+s+sd}{        coords is a list of u,v coordinates that we obtained from our data}
\PYG{l+s+sd}{        coeffs is the precomputed coefficients}
\PYG{l+s+sd}{        image is a 80x80 pixel image that represents our reconstructed image}
\PYG{l+s+sd}{        FOV is the Field of view from the telescopes. For the EHT data, our FOV is 100 micro ascs.}
\PYG{l+s+sd}{    Returns:}
\PYG{l+s+sd}{        the gradient of the loss function}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{gradient\PYGZus{}arr} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Because we are in real space}
    \PYG{n}{vis\PYGZus{}images} \PYG{o}{=} \PYG{n}{interpolate}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{FOV}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{col} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{image}\PYG{p}{[}\PYG{n}{row}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{gradient\PYGZus{}sum} \PYG{o}{=} \PYG{l+m+mi}{0}
            \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{vis\PYGZus{}data} \PYG{o}{=} \PYG{n}{data\PYGZus{}list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{vis\PYGZus{}data}
                \PYG{n}{vis\PYGZus{}image} \PYG{o}{=} \PYG{n}{vis\PYGZus{}images}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} Ask about this on Wednesday}
                \PYG{n}{term\PYGZus{}1} \PYG{o}{=} \PYG{n}{coeffs}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{,}\PYG{n}{i}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{*} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{n}{vis\PYGZus{}image}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{n}{vis\PYGZus{}data}\PYG{p}{)}\PYG{p}{)}
                \PYG{n}{term\PYGZus{}2} \PYG{o}{=} \PYG{n}{coeffs}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{,}\PYG{n}{i}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{*} \PYG{p}{(}\PYG{n}{vis\PYGZus{}image} \PYG{o}{\PYGZhy{}} \PYG{n}{vis\PYGZus{}data}\PYG{p}{)}
                \PYG{n}{gradient\PYGZus{}sum} \PYG{o}{+}\PYG{o}{=} \PYG{p}{(}\PYG{n}{term\PYGZus{}1} \PYG{o}{+} \PYG{n}{term\PYGZus{}2}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{sigma} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{)}
            \PYG{n}{gradient\PYGZus{}arr}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]} \PYG{o}{=} \PYG{n}{gradient\PYGZus{}sum}\PYG{o}{.}\PYG{n}{real}
    \PYG{k}{return} \PYG{n}{gradient\PYGZus{}arr}


\PYG{c+c1}{\PYGZsh{} Why is it made of fourier harmonics}
\PYG{c+c1}{\PYGZsh{} Setting Visibilities of 1 for the purposes of this work}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{n}{dirty\PYGZus{}gradient}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{coeffs}\PYG{p}{,} \PYG{n}{sample}\PYG{p}{,} \PYG{n}{FOV} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(\PYGZhy{}0.5, 79.5, 79.5, \PYGZhy{}0.5)
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{50044725cf3b7bb9aba8413280e2b5fac297b8a84f56bbf478d426329bef7e14}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Below is the gradient descent routine done in the fine gradient code

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{gradient\PYGZus{}descent}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{coeffs} \PYG{o}{=} \PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{FOV} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{o}{*}\PYG{n}{u}\PYG{o}{.}\PYG{n}{uas}\PYG{o}{.}\PYG{n}{to}\PYG{p}{(}\PYG{n}{u}\PYG{o}{.}\PYG{n}{rad}\PYG{p}{)}\PYG{p}{,} \PYG{n}{stopper} \PYG{o}{=} \PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{dirty} \PYG{o}{=} \PYG{k+kc}{False}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Performs gradient descent to reconstruct the image}
\PYG{l+s+sd}{    Args:}
\PYG{l+s+sd}{        image is a 80x80 pixel image that represents our reconstructed image}
\PYG{l+s+sd}{        data\PYGZus{}list is a list of data objects}
\PYG{l+s+sd}{        coords is a list of u,v coordinates that we obtained from our data}
\PYG{l+s+sd}{        coeffs is the precomputed coefficients}
\PYG{l+s+sd}{        FOV is the Field of view from the telescopes. For the EHT data, our FOV is 100 micro ascs.}
\PYG{l+s+sd}{        stopper allows the descent to stop at 20 iterations}
\PYG{l+s+sd}{        dirty changes the gradient mode to dirty kernel}
\PYG{l+s+sd}{    Returns:}
\PYG{l+s+sd}{        the reconstructed image}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{image\PYGZus{}copy} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{subok}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Uses copy of the image due to lists being mutable in python}
    \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{n}{grad} \PYG{o}{=} \PYG{k+kc}{None}
    \PYG{c+c1}{\PYGZsh{} Can also use max here, min just makes it finish quicker}
    \PYG{k}{while} \PYG{n}{grad} \PYG{o+ow}{is} \PYG{k+kc}{None} \PYG{o+ow}{or} \PYG{n}{np}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{grad}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{0.00001}\PYG{p}{:}
        \PYG{n}{t} \PYG{o}{=} \PYG{l+m+mi}{10000000} \PYG{c+c1}{\PYGZsh{} Initial Step size which resets each iteration}
        \PYG{n}{prev\PYGZus{}loss} \PYG{o}{=} \PYG{n}{loss}\PYG{p}{(}\PYG{n}{image\PYGZus{}copy}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{FOV}\PYG{o}{=}\PYG{n}{FOV}\PYG{p}{)}

        \PYG{k}{if} \PYG{n}{dirty}\PYG{p}{:}
            \PYG{n}{grad} \PYG{o}{=} \PYG{n}{dirty\PYGZus{}gradient}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{coeffs}\PYG{p}{,} \PYG{n}{image\PYGZus{}copy}\PYG{p}{)}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{n}{grad} \PYG{o}{=} \PYG{n}{gradient\PYGZus{}finite\PYGZus{}differences}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{image\PYGZus{}copy}\PYG{p}{,} \PYG{n}{FOV}\PYG{o}{=}\PYG{n}{FOV}\PYG{p}{)}

        \PYG{n}{new\PYGZus{}image} \PYG{o}{=} \PYG{n}{image\PYGZus{}copy} \PYG{o}{\PYGZhy{}} \PYG{n}{t} \PYG{o}{*} \PYG{n}{grad}\PYG{o}{.}\PYG{n}{real}
        \PYG{n}{new\PYGZus{}loss} \PYG{o}{=} \PYG{n}{loss}\PYG{p}{(}\PYG{n}{new\PYGZus{}image}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{FOV}\PYG{o}{=}\PYG{n}{FOV}\PYG{p}{)}
        
        \PYG{k}{while} \PYG{n}{new\PYGZus{}loss} \PYG{o}{\PYGZgt{}} \PYG{n}{prev\PYGZus{}loss}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} Only run when new\PYGZus{}loss \PYGZgt{} prev\PYGZus{}loss}
            \PYG{n}{new\PYGZus{}image} \PYG{o}{=} \PYG{n}{image\PYGZus{}copy} \PYG{o}{\PYGZhy{}} \PYG{n}{t} \PYG{o}{*} \PYG{n}{grad}\PYG{o}{.}\PYG{n}{real}
            \PYG{n}{new\PYGZus{}loss} \PYG{o}{=} \PYG{n}{loss}\PYG{p}{(}\PYG{n}{new\PYGZus{}image}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{FOV}\PYG{o}{=}\PYG{n}{FOV}\PYG{p}{)}
            \PYG{n}{t} \PYG{o}{/}\PYG{o}{=} \PYG{l+m+mi}{2}

        \PYG{n}{image\PYGZus{}copy} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{t} \PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{grad}\PYG{o}{.}\PYG{n}{real} \PYG{c+c1}{\PYGZsh{} Multiply by 2 to undo last divide in the while loop}
        \PYG{n}{i} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
        \PYG{k}{if} \PYG{n}{stopper} \PYG{o}{!=} \PYG{k+kc}{None}\PYG{p}{:}
            \PYG{k}{if} \PYG{n}{i} \PYG{o}{==} \PYG{n}{stopper}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} Hard stop here for notebook purposes}
                \PYG{k}{return} \PYG{n}{image\PYGZus{}copy}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{loss:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{new\PYGZus{}loss}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{image\PYGZus{}copy}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(\PYGZhy{}0.5, 79.5, 79.5, \PYGZhy{}0.5)
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{50044725cf3b7bb9aba8413280e2b5fac297b8a84f56bbf478d426329bef7e14}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Continuing Further}
\label{\detokenize{dirty_gradient:continuing-further}}
\sphinxAtStartPar
Now lets say that DFT (Discrete fourier transform) is defined as
\begin{equation*}
\begin{split}I(u,v) = \frac{1}{N}\sum^{N-1}_{i,j = 0} exp(-\frac{2\pi i}{N}(iu+jv))I_{ij}\end{split}
\end{equation*}\begin{equation*}
\begin{split}I_{ij} = \frac{1}{N}\sum^{N-1}_{i,j = 0} exp(\frac{2\pi i}{N}(iu+jv))I(u,v)\end{split}
\end{equation*}
\sphinxAtStartPar
The interpolation scheme computes \(I(u_a,v_a)\) as \(I(u_a,v_a) = \sum_{u,v = 0}^{N-1} W(u_a,v_a|u,v)I(u,v)\) where \(W(u_a,v_a|u,v)\) stands for the weights of \(u_a,v_a\) at u and v. The interpolation scheme will compute with only a few weights being non\sphinxhyphen{}zero for each a (assuming the interpolation is done in a local way). Putting this expression into \(I(u,v)\) we get
\begin{equation*}
\begin{split}\frac{\partial I(u_a,v_a)}{\partial I_{ij}} = \frac{1}{N}\sum^{N-1}_{u,v = 0} W(u_a,v_a|u,v) exp(-\frac{2\pi i}{N}(iu+jv))\end{split}
\end{equation*}
\sphinxAtStartPar
We this, we see that the partial derivative \(\frac{\partial I(u_a,v_a)}{\partial I_{ij}}\) is the interpolation of the Fourier transform kernel.

\sphinxAtStartPar
Now, we can rewrite our formula for the Dirty Image.
\begin{equation*}
\begin{split}DI(u,v) = \frac{1}{N}\sum_{i,j} exp(-\frac{2\pi i}{N}(iu+jv))DI_{ij}\end{split}
\end{equation*}\begin{equation*}
\begin{split} = \frac{1}{N}\sum_{i,j} exp(-\frac{2\pi i}{N}(iu+jv)) \sum_a \frac{1}{\sigma^2_a}\frac{\partial I^*(u_a,v_a)}{\partial I_{ij}}I(u_a,v_a)\end{split}
\end{equation*}\begin{equation*}
\begin{split} = \frac{1}{N}\sum_{i,j} exp(-\frac{2\pi i}{N}(iu+jv)) \sum_a \frac{1}{\sigma^2_a}\frac{1}{N}\sum^{N-1}_{u',v' = 0} W(u_a,v_a|u',v') exp(-\frac{2\pi i}{N}(iu'+jv'))I(u_a,v_a)\end{split}
\end{equation*}\begin{equation*}
\begin{split} = \sum_a \frac{1}{\sigma^2_a}W(u_a,v_a|u,v)I(u_a,v_a) \end{split}
\end{equation*}\begin{equation*}
\begin{split} = \sum_a \frac{1}{\sigma^2_a}W(u_a,v_a|u,v)\sum^{N-1}_{u',v' = 0} W(u_a,v_a|u',v')I(u',v')\end{split}
\end{equation*}
\sphinxAtStartPar
Now lets finally introduce the “dirty kernel” DK.
\begin{equation*}
\begin{split}DK(u,v|u',v') = \sum_a \frac{1}{\sigma^2_a}W(u_a,v_a|u,v)W(u_a,v_a|u',v')\end{split}
\end{equation*}
\sphinxAtStartPar
This transforms the dirty image equation to be
\begin{equation*}
\begin{split}DI(u,v) = \sum^{N-1}_{u',v' = 0} DK(u,v|u',v') I(u',v')\end{split}
\end{equation*}
\sphinxAtStartPar
Notice here that for each \((u,v)\) there are only a few points \((u',v')\) close by where \(DK(u,v|u',v') \neq 0\). Thus for each point \((u,v)\) in the Fourier domain, we can create a small list of \((u',v')\) points with tabulated \(DK\) values.

\sphinxAtStartPar
Another important note is that we can dirty the image quickly since the dirty kernel is able to be precomputed. We can do so since it only depends on observational data. The time complexity of going from the image to the fourier domain using DFT is about \(O(N^2lnN)\) whereas the time complexity of going from image to dirty image by using the dirty kernel method is about \(O(N^2)\).

\sphinxAtStartPar
The code below was written by Misha Stepanov in order to quickly calculate DI, DO, and DK.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{n}{N} \PYG{o}{=} \PYG{l+m+mi}{80}\PYG{p}{;}  \PYG{n}{coeff} \PYG{o}{=} \PYG{l+m+mf}{4.84813681109536e\PYGZhy{}10}\PYG{p}{;}  \PYG{n}{Breg} \PYG{o}{=} \PYG{l+m+mf}{10000.}\PYG{p}{;}  \PYG{n}{Nreg} \PYG{o}{=} \PYG{l+m+mf}{100.}

\PYG{c+c1}{\PYGZsh{} reading data}
\PYG{n}{list\PYGZus{}of\PYGZus{}strings} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{./data/SR1\PYGZus{}M87\PYGZus{}2017\PYGZus{}095\PYGZus{}hi\PYGZus{}hops\PYGZus{}netcal\PYGZus{}StokesI.csv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
  \PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{f}\PYG{p}{:}
    \PYG{n}{list\PYGZus{}of\PYGZus{}strings}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}
\PYG{n}{list\PYGZus{}of\PYGZus{}strings}\PYG{o}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{Na} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{list\PYGZus{}of\PYGZus{}strings}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{list\PYGZus{}of\PYGZus{}strings}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{UVa}\PYG{p}{,} \PYG{n}{sigma} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Na}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Na}\PYG{p}{)}
\PYG{n}{Oa} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Na}\PYG{p}{)}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n+nb}{complex}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{a} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{Na}\PYG{p}{)}\PYG{p}{:}
  \PYG{n}{current\PYGZus{}string} \PYG{o}{=} \PYG{p}{(}\PYG{n}{list\PYGZus{}of\PYGZus{}strings}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Split on commas}
  \PYG{n}{list\PYGZus{}of\PYGZus{}strings}\PYG{o}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{p}{)}
  \PYG{n}{UVa}\PYG{p}{[}\PYG{n}{a}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{UVa}\PYG{p}{[}\PYG{n}{a}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{current\PYGZus{}string}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{current\PYGZus{}string}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}
  \PYG{n}{Oa}\PYG{p}{[}\PYG{n}{a}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{current\PYGZus{}string}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{)}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{n}{j}\PYG{o}{*}\PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{current\PYGZus{}string}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{)}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mf}{180.}\PYG{p}{)}
  \PYG{n}{sigma}\PYG{p}{[}\PYG{n}{a}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{current\PYGZus{}string}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{)}
  \PYG{n}{UVa}\PYG{p}{[}\PYG{n}{a} \PYG{o}{+} \PYG{n}{Na}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Oa}\PYG{p}{[}\PYG{n}{a} \PYG{o}{+} \PYG{n}{Na}\PYG{p}{]}\PYG{p}{,} \PYG{n}{sigma}\PYG{p}{[}\PYG{n}{a} \PYG{o}{+} \PYG{n}{Na}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{UVa}\PYG{p}{[}\PYG{n}{a}\PYG{p}{]}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{n}{Oa}\PYG{p}{[}\PYG{n}{a}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{sigma}\PYG{p}{[}\PYG{n}{a}\PYG{p}{]}
\PYG{k}{del} \PYG{n}{list\PYGZus{}of\PYGZus{}strings}\PYG{p}{,} \PYG{n}{current\PYGZus{}string}

\PYG{c+c1}{\PYGZsh{} local cubic interpolation}
\PYG{k}{def} \PYG{n+nf}{cubf1}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{:}                              \PYG{c+c1}{\PYGZsh{}      8  11}
  \PYG{n}{cf1} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{+} \PYG{n}{x} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{o}{*}\PYG{n}{x}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{+} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{n}{y}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{}   8  2  3  10}
  \PYG{n}{cf2} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{+} \PYG{n}{y} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{o}{*}\PYG{n}{y}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{+} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{n}{x}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{}   4  0  1  6}
  \PYG{k}{return} \PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{p}{(}\PYG{n}{cf1} \PYG{o}{+} \PYG{n}{cf2}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{)}    \PYG{c+c1}{\PYGZsh{}      5  7}
\PYG{k}{def} \PYG{n+nf}{cubf2}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{:}  \PYG{k}{return} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n}{x}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{+} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{n}{y}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{)}
\PYG{n}{IND} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYGZbs{}
  \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{cubfun12}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{:}  \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{cubf1}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{,} \PYG{n}{cubf1}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{,} \PYGZbs{}
    \PYG{n}{cubf1}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{)}\PYG{p}{,} \PYG{n}{cubf1}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{,} \PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{)}\PYG{p}{,} \PYG{n}{cubf2}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{,} \PYG{n}{cubf2}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}\PYG{p}{,} \PYGZbs{}
    \PYG{n}{cubf2}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{,} \PYG{n}{cubf2}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,} \PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{)}\PYG{p}{,} \PYG{n}{cubf2}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{)}\PYG{p}{,} \PYG{n}{cubf2}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}\PYG{p}{,} \PYGZbs{}
    \PYG{n}{cubf2}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{,} \PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{)}\PYG{p}{,} \PYG{n}{cubf2}\PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{,} \PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}

\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{Calculate DO}
\PYG{l+s+sd}{Compare G = \PYGZhy{}2DO}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{c+c1}{\PYGZsh{} computing DO, the dirty image from observations}
\PYG{n}{DOuv} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{n}{N}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n+nb}{complex}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{a} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Na}\PYG{p}{)}\PYG{p}{:}
  \PYG{n}{m} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{mod}\PYG{p}{(}\PYG{n}{coeff}\PYG{o}{*}\PYG{n}{UVa}\PYG{p}{[}\PYG{n}{a}\PYG{p}{]}\PYG{p}{,} \PYG{n}{N}\PYG{p}{)}\PYG{p}{;}  \PYG{n}{x}\PYG{p}{,} \PYG{n}{y} \PYG{o}{=} \PYG{n}{m} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{floor}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}
  \PYG{n}{m1}\PYG{p}{,} \PYG{n}{m2} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{floor}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{mod}\PYG{p}{(}\PYG{n}{m} \PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{2.}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{N}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{)}
  \PYG{n}{C}\PYG{p}{,} \PYG{n}{CUBFUN} \PYG{o}{=} \PYG{n}{Oa}\PYG{p}{[}\PYG{n}{a}\PYG{p}{]} \PYG{o}{/} \PYG{n}{sigma}\PYG{p}{[}\PYG{n}{a}\PYG{p}{]}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{cubfun12}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}
  \PYG{k}{for} \PYG{n}{c} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{)}\PYG{p}{:}  \PYG{n}{DOuv}\PYG{p}{[}\PYG{n}{m1} \PYG{o}{+} \PYG{n}{IND}\PYG{p}{[}\PYG{n}{c}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{m2} \PYG{o}{+} \PYG{n}{IND}\PYG{p}{[}\PYG{n}{c}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{C}\PYG{o}{*}\PYG{n}{CUBFUN}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]}
\PYG{n}{DO} \PYG{o}{=} \PYG{n}{N}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{real}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{ifft2}\PYG{p}{(}\PYG{n}{DOuv}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{del} \PYG{n}{DOuv}

\PYG{c+c1}{\PYGZsh{} computing DK, the dirty kernel}
\PYG{n}{DK49}\PYG{p}{,} \PYG{n}{DK} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{n}{N}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{a} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Na}\PYG{p}{)}\PYG{p}{:}
  \PYG{n}{m} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{mod}\PYG{p}{(}\PYG{n}{coeff}\PYG{o}{*}\PYG{n}{UVa}\PYG{p}{[}\PYG{n}{a}\PYG{p}{]}\PYG{p}{,} \PYG{n}{N}\PYG{p}{)}\PYG{p}{;}  \PYG{n}{x}\PYG{p}{,} \PYG{n}{y} \PYG{o}{=} \PYG{n}{m} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{floor}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}
  \PYG{n}{m1}\PYG{p}{,} \PYG{n}{m2} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{floor}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{mod}\PYG{p}{(}\PYG{n}{m} \PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{2.}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{N}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{)}
  \PYG{n}{C}\PYG{p}{,} \PYG{n}{CUBFUN} \PYG{o}{=} \PYG{l+m+mf}{1.} \PYG{o}{/} \PYG{n}{sigma}\PYG{p}{[}\PYG{n}{a}\PYG{p}{]}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{cubfun12}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}
  \PYG{k}{for} \PYG{n}{c} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{cp} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{)}\PYG{p}{:}
      \PYG{n}{DK49}\PYG{p}{[}\PYG{n}{m1} \PYG{o}{+} \PYG{n}{IND}\PYG{p}{[}\PYG{n}{c}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{m2} \PYG{o}{+} \PYG{n}{IND}\PYG{p}{[}\PYG{n}{c}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{3} \PYG{o}{+} \PYG{n}{IND}\PYG{p}{[}\PYG{n}{cp}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{IND}\PYG{p}{[}\PYG{n}{c}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYGZbs{}
           \PYG{l+m+mi}{3} \PYG{o}{+} \PYG{n}{IND}\PYG{p}{[}\PYG{n}{cp}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{IND}\PYG{p}{[}\PYG{n}{c}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{CUBFUN}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]}\PYG{o}{*}\PYG{n}{CUBFUN}\PYG{p}{[}\PYG{n}{cp}\PYG{p}{]}\PYG{o}{*}\PYG{n}{C}
\PYG{k}{for} \PYG{n}{u} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
  \PYG{k}{for} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{du} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{:}
      \PYG{k}{for} \PYG{n}{dv} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{DK49}\PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{du}\PYG{p}{,} \PYG{n}{dv}\PYG{p}{]} \PYG{o}{!=} \PYG{l+m+mf}{0.}\PYG{p}{)}\PYG{p}{:}
          \PYG{n}{DK}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{p}{(}\PYG{p}{(}\PYG{n}{u} \PYG{o}{+} \PYG{n}{du}\PYG{p}{)} \PYG{o}{\PYGZpc{}} \PYG{n}{N}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{p}{(}\PYG{p}{(}\PYG{n}{v} \PYG{o}{+} \PYG{n}{dv}\PYG{p}{)} \PYG{o}{\PYGZpc{}} \PYG{n}{N}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{3}\PYG{p}{,} \PYGZbs{}
            \PYG{n}{DK49}\PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{du}\PYG{p}{,} \PYG{n}{dv}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{del} \PYG{n}{DK49}\PYG{p}{,} \PYG{n}{IND}\PYG{p}{,} \PYG{n}{CUBFUN}

\PYG{c+c1}{\PYGZsh{} computing DI, the dirtying of the image I}
\PYG{n}{I12}\PYG{p}{,} \PYG{n}{Iuv} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{N}\PYG{p}{,} \PYG{n}{N}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{n}{N}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n+nb}{complex}\PYG{p}{)}
\PYG{n}{DI}\PYG{p}{,} \PYG{n}{DIuv} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{n}{N}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{n}{N}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n+nb}{complex}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{calc\PYGZus{}DI}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
  \PYG{k}{global} \PYG{n}{Iuv}\PYG{p}{,} \PYG{n}{DI}\PYG{p}{,} \PYG{n}{DIuv}
  \PYG{n}{Iuv}\PYG{p}{,} \PYG{n}{DIuv} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fft2}\PYG{p}{(}\PYG{n}{I}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{n}{N}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n+nb}{complex}\PYG{p}{)}
  \PYG{k}{for} \PYG{n}{q} \PYG{o+ow}{in} \PYG{n}{DK}\PYG{p}{:}  \PYG{n}{DIuv}\PYG{p}{[}\PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{o}{*}\PYG{n}{Iuv}\PYG{p}{[}\PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{]}
  \PYG{n}{DI} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{real}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{ifft2}\PYG{p}{(}\PYG{n}{DIuv}\PYG{p}{)}\PYG{p}{)}
  \PYG{k}{return}

\PYG{c+c1}{\PYGZsh{} computing G, the gradient of the loss function}
\PYG{k}{def} \PYG{n+nf}{neighbor}\PYG{p}{(}\PYG{n}{Iat}\PYG{p}{,} \PYG{n}{Inear}\PYG{p}{)}\PYG{p}{:}  \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sign}\PYG{p}{(}\PYG{n}{Iat} \PYG{o}{\PYGZhy{}} \PYG{n}{Inear}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{calc\PYGZus{}G}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
  \PYG{k}{global} \PYG{n}{G}
  \PYG{n}{calc\PYGZus{}DI}\PYG{p}{(}\PYG{p}{)}
  \PYG{n}{G} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{p}{(}\PYG{n}{DI} \PYG{o}{\PYGZhy{}} \PYG{n}{DO}\PYG{p}{)}
  \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
      \PYG{k}{if} \PYG{p}{(}\PYG{n}{I}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{0.}\PYG{p}{)}\PYG{p}{:}  \PYG{n}{G}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{Breg}
      \PYG{k}{if} \PYG{p}{(}\PYG{n}{I}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{0.}\PYG{p}{)}\PYG{p}{:}  \PYG{n}{G}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{Nreg}
  \PYG{k}{return}

\PYG{n}{I}\PYG{p}{,} \PYG{n}{dt} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mf}{0.}\PYG{o}{*}\PYG{n}{DO}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{0.00001}

\PYG{n}{calc\PYGZus{}DI}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
6458
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Below is what the gradient looks like after running the dirty kernel code. What is remarkable is its similarity to the gradient calculated in the finite differences notebook in a fraction of the time. I am using a 2021 MacBook Pro with an M1 chip and the dirty kernel code took 2.5 seconds while the finite differences code took 34.4 seconds.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{DO}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{coeff = FOV}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Text(0.5, 1.0, \PYGZsq{}coeff = FOV\PYGZsq{})
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{72a868abe5d9f0a860814df0f5f6d8831975213a675c42ec32baa48211787863}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\chapter{Utility Appendix}
\label{\detokenize{utility:utility-appendix}}\label{\detokenize{utility::doc}}
\sphinxAtStartPar
This is the Utility File with all of the functions put in so that all the Juypter Notebooks can use any of these functions

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{cmath}
\PYG{k+kn}{import} \PYG{n+nn}{math}
\PYG{k+kn}{from} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{optimize} \PYG{k+kn}{import} \PYG{n}{fmin}\PYG{p}{,} \PYG{n}{minimize}
\PYG{k+kn}{from} \PYG{n+nn}{astropy} \PYG{k+kn}{import} \PYG{n}{units} \PYG{k}{as} \PYG{n}{u}
\PYG{k+kn}{from} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{interpolate} \PYG{k+kn}{import} \PYG{n}{RegularGridInterpolator}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{import} \PYG{n+nn}{copy}
\PYG{o}{\PYGZpc{}}\PYG{k}{matplotlib} inline
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{data}\PYG{p}{:}
    \PYG{n}{u}\PYG{p}{:} \PYG{n+nb}{float}
    \PYG{n}{v}\PYG{p}{:} \PYG{n+nb}{float}
    \PYG{n}{phase}\PYG{p}{:} \PYG{n+nb}{float}
    \PYG{n}{amp}\PYG{p}{:} \PYG{n+nb}{float}
    \PYG{n}{sigma}\PYG{p}{:} \PYG{n+nb}{float}
    \PYG{n}{vis\PYGZus{}data}\PYG{p}{:} \PYG{n+nb}{complex}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{phase}\PYG{p}{,} \PYG{n}{amp}\PYG{p}{,} \PYG{n}{sigma}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{u} \PYG{o}{=} \PYG{n}{u}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{v} \PYG{o}{=} \PYG{n}{v}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{phase} \PYG{o}{=} \PYG{n}{phase}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{amp} \PYG{o}{=} \PYG{n}{amp}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{sigma} \PYG{o}{=} \PYG{n}{sigma}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{vis\PYGZus{}data} \PYG{o}{=} \PYG{n}{amp} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{n}{j} \PYG{o}{*} \PYG{n}{math}\PYG{o}{.}\PYG{n}{radians}\PYG{p}{(}\PYG{n}{phase}\PYG{p}{)}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}repr\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{[u: }\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{u}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{, v: }\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{v}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{]}\PYG{l+s+s2}{\PYGZdq{}}

    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}str\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{[u: }\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{u}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{, v: }\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{v}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{]}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{process\PYGZus{}data}\PYG{p}{(}\PYG{n}{data\PYGZus{}df}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Processes the data in the dataframe into a coords list and data objects}
\PYG{l+s+sd}{    Args:}
\PYG{l+s+sd}{        data\PYGZus{}df is a pandas data frame of the data}
\PYG{l+s+sd}{    Returns:}
\PYG{l+s+sd}{        a list of coordinates in u,v space}
\PYG{l+s+sd}{        a list of data objects}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}

    \PYG{n}{coords} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{data\PYGZus{}list} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{data\PYGZus{}df}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{data\PYGZus{}list}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{data}\PYG{p}{(}\PYG{n}{data\PYGZus{}df}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{U(lambda)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{data\PYGZus{}df}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{V(lambda)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{data\PYGZus{}df}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Iphase(d)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{data\PYGZus{}df}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Iamp(Jy)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{data\PYGZus{}df}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Isigma(Jy)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{coords}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{[}\PYG{n}{data\PYGZus{}df}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{U(lambda)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{data\PYGZus{}df}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{V(lambda)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{coords} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{coords}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{read\PYGZus{}data}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    reads the data from a file into a pandas dataframe}
\PYG{l+s+sd}{    Args:}
\PYG{l+s+sd}{        filename is a string that represents a csv file}
\PYG{l+s+sd}{    Returns:}
\PYG{l+s+sd}{        a pandas dataframe}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{read\PYGZus{}csv}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{df}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df} \PYG{o}{=} \PYG{n}{read\PYGZus{}data}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{./data/SR1\PYGZus{}M87\PYGZus{}2017\PYGZus{}095\PYGZus{}hi\PYGZus{}hops\PYGZus{}netcal\PYGZus{}StokesI.csv}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{coords}\PYG{p}{,} \PYG{n}{data\PYGZus{}list} \PYG{o}{=} \PYG{n}{process\PYGZus{}data}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{loss}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{:} \PYG{n+nb}{list}\PYG{p}{[}\PYG{n}{data}\PYG{p}{]}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{p} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{reg\PYGZus{}weight} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{FOV} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{o}{*}\PYG{n}{u}\PYG{o}{.}\PYG{n}{uas}\PYG{o}{.}\PYG{n}{to}\PYG{p}{(}\PYG{n}{u}\PYG{o}{.}\PYG{n}{rad}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    calculates the loss of an image compared to the data given}
\PYG{l+s+sd}{    Args:}
\PYG{l+s+sd}{        image is a 80x80 pixel image that represents our reconstructed image}
\PYG{l+s+sd}{        coords is a list of u,v coordinates that we obtained from our data}
\PYG{l+s+sd}{        p is the kind of norm to be used}
\PYG{l+s+sd}{        reg\PYGZus{}weight is the regularizer weight}
\PYG{l+s+sd}{        FOV is the Field of view from the telescopes. For the EHT data, our FOV is 100 micro ascs.}
\PYG{l+s+sd}{    Returns:}
\PYG{l+s+sd}{        a loss value}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{error\PYGZus{}sum} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{n}{vis\PYGZus{}images} \PYG{o}{=} \PYG{n}{interpolate}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{FOV}\PYG{p}{)}
    
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{vis\PYGZus{}data} \PYG{o}{=} \PYG{n}{data\PYGZus{}list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{amp} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{n}{j} \PYG{o}{*} \PYG{n}{math}\PYG{o}{.}\PYG{n}{radians}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{phase}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{vis\PYGZus{}image} \PYG{o}{=} \PYG{n}{vis\PYGZus{}images}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
        \PYG{n}{error} \PYG{o}{=} \PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{vis\PYGZus{}image}\PYG{o}{\PYGZhy{}}\PYG{n}{vis\PYGZus{}data}\PYG{p}{)} \PYG{o}{/} \PYG{n}{data\PYGZus{}list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{sigma}\PYG{p}{)} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}
        \PYG{n}{error\PYGZus{}sum} \PYG{o}{+}\PYG{o}{=} \PYG{n}{error}
    
    \PYG{k}{return} \PYG{n}{error\PYGZus{}sum} \PYG{o}{+} \PYG{n}{reg\PYGZus{}weight} \PYG{o}{*} \PYG{n}{calc\PYGZus{}regularizer}\PYG{p}{(}\PYG{n}{image}\PYG{o}{=}\PYG{n}{image}\PYG{p}{,} \PYG{n}{tsv}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{p}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{do\PYGZus{}sample}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Collects n samples from a sample image}
\PYG{l+s+sd}{    Args:}
\PYG{l+s+sd}{        n is the number of samples as an integer}
\PYG{l+s+sd}{    Returns:}
\PYG{l+s+sd}{        a list of coordinates in u,v space}
\PYG{l+s+sd}{        a list of data objects}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{coords} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{data\PYGZus{}list} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{ft\PYGZus{}image} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fftshift}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fft2}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{coords}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{10}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{10}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{data\PYGZus{}list}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{data}\PYG{p}{(}\PYG{n}{coords}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ft\PYGZus{}image}\PYG{p}{[}\PYG{n}{coords}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{+}\PYG{l+m+mi}{40}\PYG{p}{]}\PYG{p}{[}\PYG{n}{coords}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{l+m+mi}{40}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{calculate\PYGZus{}losses}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Calculates the losses of the image by shifting it around }
\PYG{l+s+sd}{    Args:}
\PYG{l+s+sd}{        None}
\PYG{l+s+sd}{    Returns:}
\PYG{l+s+sd}{        an array of losses where the index is how much the image is shifted starting with \PYGZhy{}40 to 40}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{loss\PYGZus{}arr} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{)}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{image\PYGZus{}1} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{roll}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{,} \PYG{n}{i}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Right shifts}
        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{image\PYGZus{}2} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{roll}\PYG{p}{(}\PYG{n}{image\PYGZus{}1}\PYG{p}{,} \PYG{n}{j}\PYG{p}{,} \PYG{n}{axis} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Up shifts}
            \PYG{n}{loss\PYGZus{}arr}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{loss}\PYG{p}{(}\PYG{n}{image\PYGZus{}2}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{reg\PYGZus{}weight}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{FOV}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
            
    \PYG{n}{loss\PYGZus{}arr1} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{roll}\PYG{p}{(}\PYG{n}{loss\PYGZus{}arr}\PYG{p}{,} \PYG{l+m+mi}{40}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{n}{loss\PYGZus{}arr2} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{roll}\PYG{p}{(}\PYG{n}{loss\PYGZus{}arr1}\PYG{p}{,} \PYG{l+m+mi}{40}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}

    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{loss\PYGZus{}arr2}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{axis}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{off}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{loss\PYGZus{}arr}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{FOV}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Interpolates the values of each coordinate in coords in the fourier domain of image}
\PYG{l+s+sd}{    Args:}
\PYG{l+s+sd}{        image is a 80x80 pixel image that represents our reconstructed image}
\PYG{l+s+sd}{        coords is a list of u,v coordinates that we obtained from our data}
\PYG{l+s+sd}{        FOV is the Field of view from the telescopes. For the EHT data, our FOV is 100 micro ascs.}
\PYG{l+s+sd}{    Returns:}
\PYG{l+s+sd}{        The interpolated values at the coordinates based on image}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}

    \PYG{n}{ft\PYGZus{}image} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fftshift}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fft2}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{p}{)}

    \PYG{n}{k\PYGZus{}FOV} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{FOV}

    \PYG{n}{kx} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fftshift}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fftfreq}\PYG{p}{(}\PYG{n}{ft\PYGZus{}image}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{d} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{p}{(}\PYG{n}{k\PYGZus{}FOV}\PYG{o}{*}\PYG{n}{ft\PYGZus{}image}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{ky} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fftshift}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fftfreq}\PYG{p}{(}\PYG{n}{ft\PYGZus{}image}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{d} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{p}{(}\PYG{n}{k\PYGZus{}FOV}\PYG{o}{*}\PYG{n}{ft\PYGZus{}image}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}

    \PYG{n}{interp\PYGZus{}real} \PYG{o}{=} \PYG{n}{RegularGridInterpolator}\PYG{p}{(}\PYG{p}{(}\PYG{n}{kx}\PYG{p}{,} \PYG{n}{ky}\PYG{p}{)}\PYG{p}{,} \PYG{n}{ft\PYGZus{}image}\PYG{o}{.}\PYG{n}{real}\PYG{p}{,} \PYG{n}{bounds\PYGZus{}error}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{method}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{linear}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{interp\PYGZus{}imag} \PYG{o}{=} \PYG{n}{RegularGridInterpolator}\PYG{p}{(}\PYG{p}{(}\PYG{n}{kx}\PYG{p}{,} \PYG{n}{ky}\PYG{p}{)}\PYG{p}{,} \PYG{n}{ft\PYGZus{}image}\PYG{o}{.}\PYG{n}{imag}\PYG{p}{,} \PYG{n}{bounds\PYGZus{}error}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{method}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{linear}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{n}{real} \PYG{o}{=} \PYG{n}{interp\PYGZus{}real}\PYG{p}{(}\PYG{n}{coords}\PYG{p}{)}
    \PYG{n}{imag} \PYG{o}{=} \PYG{n}{interp\PYGZus{}imag}\PYG{p}{(}\PYG{n}{coords}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{real} \PYG{o}{+} \PYG{n}{imag} \PYG{o}{*} \PYG{l+m+mi}{1}\PYG{n}{j}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{calc\PYGZus{}regularizer}\PYG{p}{(}\PYG{n}{image}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{,} \PYG{n}{tsv}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{p}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Calculates the regularizer according to total squared variation}
\PYG{l+s+sd}{    Args:}
\PYG{l+s+sd}{        image is a 80x80 pixel image that represents our reconstructed image}
\PYG{l+s+sd}{        p is the kind of norm to be used}
\PYG{l+s+sd}{        tsv is the flag for total squared variation}
\PYG{l+s+sd}{    Returns:}
\PYG{l+s+sd}{        the regularizer}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{if} \PYG{n}{tsv} \PYG{o+ow}{and} \PYG{n}{p} \PYG{o}{==} \PYG{k+kc}{None}\PYG{p}{:}
        \PYG{k}{raise} \PYG{n+ne}{Exception}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{p value not set}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{reg} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{k}{if} \PYG{n}{tsv}\PYG{p}{:}
        \PYG{n}{image\PYGZus{}lshift} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{subok}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
        \PYG{n}{image\PYGZus{}lshift} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{roll}\PYG{p}{(}\PYG{n}{image\PYGZus{}lshift}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
        \PYG{n}{image\PYGZus{}lshift}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{image\PYGZus{}lshift}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]} 
        \PYG{n}{image\PYGZus{}upshift} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{subok}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
        \PYG{n}{image\PYGZus{}upshift} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{roll}\PYG{p}{(}\PYG{n}{image\PYGZus{}upshift}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{n}{image\PYGZus{}upshift}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{image\PYGZus{}upshift}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]} 

        \PYG{n}{term\PYGZus{}1} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{power}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{absolute}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{subtract}\PYG{p}{(}\PYG{n}{image\PYGZus{}lshift}\PYG{p}{,} \PYG{n}{image}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}\PYG{n}{p}\PYG{p}{)}
        \PYG{n}{term\PYGZus{}2} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{power}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{absolute}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{subtract}\PYG{p}{(}\PYG{n}{image\PYGZus{}upshift}\PYG{p}{,} \PYG{n}{image}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}\PYG{n}{p}\PYG{p}{)}
        \PYG{n}{reg} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{term\PYGZus{}1}\PYG{p}{,}\PYG{n}{term\PYGZus{}2}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{return} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{n}{reg}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{gradient\PYGZus{}regularizer}\PYG{p}{(}\PYG{n}{image}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Calculates the gradient of the regularizer}
\PYG{l+s+sd}{    Args:}
\PYG{l+s+sd}{        image is a 80x80 pixel image that represents our reconstructed image}
\PYG{l+s+sd}{    Returns:}
\PYG{l+s+sd}{        the gradient of the regularizer}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{image\PYGZus{}lshift} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{subok}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
    \PYG{n}{image\PYGZus{}lshift} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{roll}\PYG{p}{(}\PYG{n}{image\PYGZus{}lshift}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{n}{image\PYGZus{}lshift}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{image\PYGZus{}lshift}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]} 
    \PYG{n}{image\PYGZus{}upshift} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{subok}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
    \PYG{n}{image\PYGZus{}upshift} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{roll}\PYG{p}{(}\PYG{n}{image\PYGZus{}upshift}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n}{image\PYGZus{}upshift}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{image\PYGZus{}upshift}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]} 
    \PYG{n}{image\PYGZus{}rshift} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{subok}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
    \PYG{n}{image\PYGZus{}rshift} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{roll}\PYG{p}{(}\PYG{n}{image\PYGZus{}rshift}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{n}{image\PYGZus{}rshift}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{image\PYGZus{}rshift}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]} 
    \PYG{n}{image\PYGZus{}dshift} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{subok}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
    \PYG{n}{image\PYGZus{}dshift} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{roll}\PYG{p}{(}\PYG{n}{image\PYGZus{}dshift}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n}{image\PYGZus{}dshift}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{image\PYGZus{}lshift}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} 
    \PYG{n}{g\PYGZus{}reg} \PYG{o}{=} \PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{image} \PYG{o}{\PYGZhy{}} \PYG{n}{image\PYGZus{}lshift} \PYG{o}{\PYGZhy{}} \PYG{n}{image\PYGZus{}upshift} \PYG{o}{\PYGZhy{}} \PYG{n}{image\PYGZus{}rshift} \PYG{o}{\PYGZhy{}} \PYG{n}{image\PYGZus{}dshift}
    \PYG{k}{return} \PYG{n}{g\PYGZus{}reg}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{gradient\PYGZus{}finite\PYGZus{}differences}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{:} \PYG{n+nb}{list}\PYG{p}{[}\PYG{n}{data}\PYG{p}{]}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{image}\PYG{p}{,} \PYG{n}{mode} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{FOV} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{o}{*}\PYG{n}{u}\PYG{o}{.}\PYG{n}{uas}\PYG{o}{.}\PYG{n}{to}\PYG{p}{(}\PYG{n}{u}\PYG{o}{.}\PYG{n}{rad}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Calculates a gradient based on finite differences}
\PYG{l+s+sd}{    Args:}
\PYG{l+s+sd}{        data\PYGZus{}list is a list of data objects}
\PYG{l+s+sd}{        coords is a list of u,v coordinates that we obtained from our data}
\PYG{l+s+sd}{        image is a 80x80 pixel image that represents our reconstructed image}
\PYG{l+s+sd}{        mode is the type of difference used: 0 For central, \PYGZhy{}1 for backward, 1 for forward}
\PYG{l+s+sd}{        FOV is the Field of view from the telescopes. For the EHT data, our FOV is 100 micro ascs.}
\PYG{l+s+sd}{    Returns:}
\PYG{l+s+sd}{        the gradient of the loss function}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{image\PYGZus{}copy} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{subok}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
    \PYG{n}{upper\PYGZus{}diff}\PYG{p}{:} \PYG{n+nb}{float}
    \PYG{n}{lower\PYGZus{}diff}\PYG{p}{:} \PYG{n+nb}{float}
    \PYG{n}{h}\PYG{p}{:} \PYG{n+nb}{float}
    \PYG{n}{gradient\PYGZus{}arr} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{p}{,}\PYG{n}{dtype}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{complex\PYGZus{}}\PYG{p}{)}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{mode} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} Central difference}
        \PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{for} \PYG{n}{col} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{image}\PYG{p}{[}\PYG{n}{row}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{image\PYGZus{}copy}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}6} \PYG{o}{/} \PYG{l+m+mi}{2}
                \PYG{n}{upper\PYGZus{}diff} \PYG{o}{=} \PYG{n}{loss}\PYG{p}{(}\PYG{n}{image\PYGZus{}copy}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{FOV}\PYG{o}{=}\PYG{n}{FOV}\PYG{p}{)}
                \PYG{n}{image\PYGZus{}copy}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}6}
                \PYG{n}{lower\PYGZus{}diff} \PYG{o}{=} \PYG{n}{loss}\PYG{p}{(}\PYG{n}{image\PYGZus{}copy}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{FOV}\PYG{o}{=}\PYG{n}{FOV}\PYG{p}{)}
                \PYG{n}{image\PYGZus{}copy}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]} \PYG{o}{=} \PYG{n}{image}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} Reset that pixel to original value}
                \PYG{n}{gradient\PYGZus{}arr}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{n}{upper\PYGZus{}diff} \PYG{o}{\PYGZhy{}} \PYG{n}{lower\PYGZus{}diff}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mf}{1e\PYGZhy{}6}
    \PYG{k}{elif} \PYG{p}{(}\PYG{n}{mode} \PYG{o}{==} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} Backward difference}
        \PYG{n}{upper\PYGZus{}diff} \PYG{o}{=} \PYG{n}{loss}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{FOV}\PYG{o}{=}\PYG{n}{FOV}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{for} \PYG{n}{col} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{image}\PYG{p}{[}\PYG{n}{row}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{image\PYGZus{}copy}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}8}
                \PYG{n}{lower\PYGZus{}diff} \PYG{o}{=} \PYG{n}{loss}\PYG{p}{(}\PYG{n}{image\PYGZus{}copy}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{FOV}\PYG{o}{=}\PYG{n}{FOV}\PYG{p}{)}
                \PYG{n}{gradient\PYGZus{}arr}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{n}{upper\PYGZus{}diff} \PYG{o}{\PYGZhy{}} \PYG{n}{lower\PYGZus{}diff}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mf}{1e\PYGZhy{}8}
                \PYG{n}{image\PYGZus{}copy}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]} \PYG{o}{=} \PYG{n}{image}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]}
    \PYG{k}{elif} \PYG{p}{(}\PYG{n}{mode} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{:} \PYG{c+c1}{\PYGZsh{} Forward difference is default}
        \PYG{n}{lower\PYGZus{}diff} \PYG{o}{=} \PYG{n}{loss}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{FOV}\PYG{o}{=}\PYG{n}{FOV}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{for} \PYG{n}{col} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{image}\PYG{p}{[}\PYG{n}{row}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{image\PYGZus{}copy}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}8} 
                \PYG{n}{upper\PYGZus{}diff} \PYG{o}{=} \PYG{n}{loss}\PYG{p}{(}\PYG{n}{image\PYGZus{}copy}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{FOV}\PYG{o}{=}\PYG{n}{FOV}\PYG{p}{)}
                \PYG{n}{gradient\PYGZus{}arr}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{n}{upper\PYGZus{}diff} \PYG{o}{\PYGZhy{}} \PYG{n}{lower\PYGZus{}diff}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mf}{1e\PYGZhy{}8}
                \PYG{n}{image\PYGZus{}copy}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]} \PYG{o}{=} \PYG{n}{image}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{k}{raise} \PYG{n+ne}{ValueError}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Incorrect mode for finite differences}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{gradient\PYGZus{}arr}\PYG{o}{.}\PYG{n}{real}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{gradient\PYGZus{}descent}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{coeffs} \PYG{o}{=} \PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{FOV} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{o}{*}\PYG{n}{u}\PYG{o}{.}\PYG{n}{uas}\PYG{o}{.}\PYG{n}{to}\PYG{p}{(}\PYG{n}{u}\PYG{o}{.}\PYG{n}{rad}\PYG{p}{)}\PYG{p}{,} \PYG{n}{stopper} \PYG{o}{=} \PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{dirty} \PYG{o}{=} \PYG{k+kc}{False}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Performs gradient descent to reconstruct the image}
\PYG{l+s+sd}{    Args:}
\PYG{l+s+sd}{        image is a 80x80 pixel image that represents our reconstructed image}
\PYG{l+s+sd}{        data\PYGZus{}list is a list of data objects}
\PYG{l+s+sd}{        coords is a list of u,v coordinates that we obtained from our data}
\PYG{l+s+sd}{        coeffs is the precomputed coefficients}
\PYG{l+s+sd}{        FOV is the Field of view from the telescopes. For the EHT data, our FOV is 100 micro ascs.}
\PYG{l+s+sd}{        stopper allows the descent to stop at 20 iterations}
\PYG{l+s+sd}{        dirty changes the gradient mode to dirty kernel}
\PYG{l+s+sd}{    Returns:}
\PYG{l+s+sd}{        the reconstructed image}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{image\PYGZus{}copy} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{subok}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Uses copy of the image due to lists being mutable in python}
    \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{n}{grad} \PYG{o}{=} \PYG{k+kc}{None}
    \PYG{c+c1}{\PYGZsh{} Can also use max here, min just makes it finish quicker}
    \PYG{k}{while} \PYG{n}{grad} \PYG{o+ow}{is} \PYG{k+kc}{None} \PYG{o+ow}{or} \PYG{n}{np}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{grad}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{0.00001}\PYG{p}{:}
        \PYG{n}{t} \PYG{o}{=} \PYG{l+m+mi}{10000000} \PYG{c+c1}{\PYGZsh{} Initial Step size which resets each iteration}
        \PYG{n}{prev\PYGZus{}loss} \PYG{o}{=} \PYG{n}{loss}\PYG{p}{(}\PYG{n}{image\PYGZus{}copy}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{FOV}\PYG{o}{=}\PYG{n}{FOV}\PYG{p}{)}

        \PYG{k}{if} \PYG{n}{dirty}\PYG{p}{:}
            \PYG{n}{grad} \PYG{o}{=} \PYG{n}{dirty\PYGZus{}gradient}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{coeffs}\PYG{p}{,} \PYG{n}{image\PYGZus{}copy}\PYG{p}{)}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{n}{grad} \PYG{o}{=} \PYG{n}{gradient\PYGZus{}finite\PYGZus{}differences}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{image\PYGZus{}copy}\PYG{p}{,} \PYG{n}{FOV}\PYG{o}{=}\PYG{n}{FOV}\PYG{p}{)}

        \PYG{n}{new\PYGZus{}image} \PYG{o}{=} \PYG{n}{image\PYGZus{}copy} \PYG{o}{\PYGZhy{}} \PYG{n}{t} \PYG{o}{*} \PYG{n}{grad}\PYG{o}{.}\PYG{n}{real}
        \PYG{n}{new\PYGZus{}loss} \PYG{o}{=} \PYG{n}{loss}\PYG{p}{(}\PYG{n}{new\PYGZus{}image}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{FOV}\PYG{o}{=}\PYG{n}{FOV}\PYG{p}{)}
        
        \PYG{k}{while} \PYG{n}{new\PYGZus{}loss} \PYG{o}{\PYGZgt{}} \PYG{n}{prev\PYGZus{}loss}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} Only run when new\PYGZus{}loss \PYGZgt{} prev\PYGZus{}loss}
            \PYG{n}{new\PYGZus{}image} \PYG{o}{=} \PYG{n}{image\PYGZus{}copy} \PYG{o}{\PYGZhy{}} \PYG{n}{t} \PYG{o}{*} \PYG{n}{grad}\PYG{o}{.}\PYG{n}{real}
            \PYG{n}{new\PYGZus{}loss} \PYG{o}{=} \PYG{n}{loss}\PYG{p}{(}\PYG{n}{new\PYGZus{}image}\PYG{p}{,} \PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{FOV}\PYG{o}{=}\PYG{n}{FOV}\PYG{p}{)}
            \PYG{n}{t} \PYG{o}{/}\PYG{o}{=} \PYG{l+m+mi}{2}

        \PYG{n}{image\PYGZus{}copy} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{t} \PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{grad}\PYG{o}{.}\PYG{n}{real} \PYG{c+c1}{\PYGZsh{} Multiply by 2 to undo last divide in the while loop}
        \PYG{n}{i} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
        \PYG{k}{if} \PYG{n}{stopper} \PYG{o}{!=} \PYG{k+kc}{None}\PYG{p}{:}
            \PYG{k}{if} \PYG{n}{i} \PYG{o}{==} \PYG{n}{stopper}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} Hard stop here for notebook purposes}
                \PYG{k}{return} \PYG{n}{image\PYGZus{}copy}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{loss:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{new\PYGZus{}loss}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{image\PYGZus{}copy}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{preprocess\PYGZus{}gradient}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{image}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Precomputed the coefficients decribed in dirty gradient}
\PYG{l+s+sd}{    Args:}
\PYG{l+s+sd}{        data\PYGZus{}list is a list of data objects}
\PYG{l+s+sd}{        coords is a list of u,v coordinates that we obtained from our data}
\PYG{l+s+sd}{        image is a 80x80 pixel image that represents our reconstructed image}
\PYG{l+s+sd}{    Returns:}
\PYG{l+s+sd}{        a 4d list of coefficients}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{r}\PYG{p}{,} \PYG{n}{c} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}
    \PYG{n}{preprocessed} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{[}\PYG{n}{r}\PYG{p}{,}\PYG{n}{c}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{complex\PYGZus{}}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{col} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{image}\PYG{p}{[}\PYG{n}{row}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{for} \PYG{n}{datum} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{term} \PYG{o}{=} \PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{*}\PYG{l+m+mi}{1}\PYG{n}{j}\PYG{p}{)}\PYG{o}{/}\PYG{n}{image}\PYG{o}{.}\PYG{n}{size}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n}{row}\PYG{o}{*}\PYG{n}{coords}\PYG{p}{[}\PYG{n}{datum}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{n}{col}\PYG{o}{*}\PYG{n}{coords}\PYG{p}{[}\PYG{n}{datum}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}.size for numpy array returns \PYGZsh{} of rows * \PYGZsh{} of cols}
                \PYG{n}{term\PYGZus{}1} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{term}\PYG{p}{)}
                \PYG{n}{term\PYGZus{}2} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{term}\PYG{p}{)}
                \PYG{n}{preprocessed}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{,}\PYG{n}{datum}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{term\PYGZus{}1}
                \PYG{n}{preprocessed}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{,}\PYG{n}{datum}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{term\PYGZus{}2}
    \PYG{k}{return} \PYG{n}{preprocessed}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{dirty\PYGZus{}gradient}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{:} \PYG{n+nb}{list}\PYG{p}{[}\PYG{n}{data}\PYG{p}{]}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{coeffs}\PYG{p}{,} \PYG{n}{image}\PYG{p}{,} \PYG{n}{FOV} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{o}{*}\PYG{n}{u}\PYG{o}{.}\PYG{n}{uas}\PYG{o}{.}\PYG{n}{to}\PYG{p}{(}\PYG{n}{u}\PYG{o}{.}\PYG{n}{rad}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Calculates a gradient based on dirting the image}
\PYG{l+s+sd}{    Args:}
\PYG{l+s+sd}{        data\PYGZus{}list is a list of data objects}
\PYG{l+s+sd}{        coords is a list of u,v coordinates that we obtained from our data}
\PYG{l+s+sd}{        coeffs is the precomputed coefficients}
\PYG{l+s+sd}{        image is a 80x80 pixel image that represents our reconstructed image}
\PYG{l+s+sd}{        FOV is the Field of view from the telescopes. For the EHT data, our FOV is 100 micro ascs.}
\PYG{l+s+sd}{    Returns:}
\PYG{l+s+sd}{        the gradient of the loss function}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{gradient\PYGZus{}arr} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Because we are in real space}
    \PYG{n}{vis\PYGZus{}images} \PYG{o}{=} \PYG{n}{interpolate}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{coords}\PYG{p}{,} \PYG{n}{FOV}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{col} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{image}\PYG{p}{[}\PYG{n}{row}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{gradient\PYGZus{}sum} \PYG{o}{=} \PYG{l+m+mi}{0}
            \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{vis\PYGZus{}data} \PYG{o}{=} \PYG{n}{data\PYGZus{}list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{vis\PYGZus{}data}
                \PYG{n}{vis\PYGZus{}image} \PYG{o}{=} \PYG{n}{vis\PYGZus{}images}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} Ask about this on Wednesday}
                \PYG{n}{term\PYGZus{}1} \PYG{o}{=} \PYG{n}{coeffs}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{,}\PYG{n}{i}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{*} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{n}{vis\PYGZus{}image}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{n}{vis\PYGZus{}data}\PYG{p}{)}\PYG{p}{)}
                \PYG{n}{term\PYGZus{}2} \PYG{o}{=} \PYG{n}{coeffs}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{,}\PYG{n}{i}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{*} \PYG{p}{(}\PYG{n}{vis\PYGZus{}image} \PYG{o}{\PYGZhy{}} \PYG{n}{vis\PYGZus{}data}\PYG{p}{)}
                \PYG{n}{gradient\PYGZus{}sum} \PYG{o}{+}\PYG{o}{=} \PYG{p}{(}\PYG{n}{term\PYGZus{}1} \PYG{o}{+} \PYG{n}{term\PYGZus{}2}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{data\PYGZus{}list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{sigma} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{)}
            \PYG{n}{gradient\PYGZus{}arr}\PYG{p}{[}\PYG{n}{row}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]} \PYG{o}{=} \PYG{n}{gradient\PYGZus{}sum}\PYG{o}{.}\PYG{n}{real}
    \PYG{k}{return} \PYG{n}{gradient\PYGZus{}arr}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}






\renewcommand{\indexname}{Index}
\printindex
\end{document}